var searchIndex = {};
searchIndex['os1'] = {"items":[[0,"","os1","The os1 kernel is written and compiled as a library. It is then\ncompiled and linked together with assembly files to produce a binary.\nThe binary is written to the hard disk, which is then loaded.",null,null],[5,"store_kcontext","","Save the `KContext` of the current process to its process struct",null,null],[5,"_proc_yield","","The unsafe function that does the actual work of choosing the\nnext process and switching to it.",null,{"inputs":[{"name":"option"}],"output":null}],[5,"pic_irq","","Rust-side IRQ handling code",null,{"inputs":[{"name":"usize"}],"output":null}],[5,"vmm_page_fault","","The Rust-side code of the page fault handler.",null,{"inputs":[{"name":"usize"}],"output":null}],[5,"kernel_main","","This is the entry point to the kernel. It is the first rust code that runs.",null,{"inputs":[],"output":null}],[0,"debug","","This module allows the user to print to QEMU's serial console.",null,null],[3,"Debug","os1::debug","A struct to write data to the console port",null,null],[17,"PORT","","Port to output to serial console",null,null],[11,"write_bytes","","Wait for the port, then write the given array of bytes",0,null],[11,"write_str","","Take a string slice and write to the serial console",0,{"inputs":[{"name":"debug"},{"name":"str"}],"output":{"name":"result"}}],[0,"bare_bones","os1","This module contains some basic functionality that libstd would normally\notherwise provide. Most importantly, it defines `rust_begin_unwind` which is\nused by `panic!`.",null,null],[5,"stack_exhausted","os1::bare_bones","",null,{"inputs":[],"output":null}],[5,"eh_personality","","",null,{"inputs":[],"output":null}],[5,"rust_begin_unwind","","This function is used by `panic!` to display an error message.",null,{"inputs":[{"name":"arguments"},{"name":"str"},{"name":"u32"}],"output":null}],[0,"vec","os1","A simple vector implementation",null,null],[3,"Vec","os1::vec","A vector implementation.\n- Amortized O(1) push to end\n- O(1) pop from end\n- O(1) access to any element\n- Automatic memory management\n- Indexable with [] operator",null,null],[12,"buf","","",1,null],[12,"len","","",1,null],[11,"new","","Create a new empty vector",1,{"inputs":[{"name":"vec"}],"output":{"name":"vec"}}],[11,"push","","Push the element to the end",1,{"inputs":[{"name":"vec"},{"name":"t"}],"output":null}],[11,"pop","","Pop and return the last element",1,{"inputs":[{"name":"vec"}],"output":{"name":"option"}}],[11,"len","","Return the number of elements",1,{"inputs":[{"name":"vec"}],"output":{"name":"usize"}}],[11,"index","","",1,{"inputs":[{"name":"vec"},{"name":"usize"}],"output":{"name":"t"}}],[11,"index_mut","","",1,{"inputs":[{"name":"vec"},{"name":"usize"}],"output":{"name":"t"}}],[11,"drop","","",1,{"inputs":[{"name":"vec"}],"output":null}],[0,"linked_list","os1","A doubly-linked list with owned nodes modified slightly from the std library.",null,null],[3,"LinkedList","os1::linked_list","A doubly-linked list.",null,null],[12,"length","","",2,null],[12,"list_head","","",2,null],[12,"list_tail","","",2,null],[3,"Rawlink","","",null,null],[12,"p","","",3,null],[3,"Node","","",null,null],[12,"next","","",4,null],[12,"prev","","",4,null],[12,"value","","",4,null],[3,"Iter","","An iterator over references to the items of a `LinkedList`.",null,null],[12,"head","","",5,null],[12,"tail","","",5,null],[12,"nelem","","",5,null],[3,"IterMut","","An iterator over mutable references to the items of a `LinkedList`.",null,null],[12,"list","","",6,null],[12,"head","","",6,null],[12,"tail","","",6,null],[12,"nelem","","",6,null],[3,"IntoIter","","An iterator over mutable references to the items of a `LinkedList`.",null,null],[12,"list","","",7,null],[5,"link_no_prev","","Clear the .prev field on `next`, then return `Some(next)`",null,{"inputs":[{"name":"box"}],"output":{"name":"link"}}],[6,"Link","","",null,null],[11,"clone","","",5,{"inputs":[{"name":"iter"}],"output":{"name":"iter"}}],[11,"clone","","",7,{"inputs":[{"name":"intoiter"}],"output":{"name":"intoiter"}}],[11,"none","","Like Option::None for Rawlink",3,{"inputs":[{"name":"rawlink"}],"output":{"name":"rawlink"}}],[11,"some","","Like Option::Some for Rawlink",3,{"inputs":[{"name":"rawlink"},{"name":"t"}],"output":{"name":"rawlink"}}],[11,"resolve","","Convert the `Rawlink` into an Option value",3,{"inputs":[{"name":"rawlink"}],"output":{"name":"option"}}],[11,"resolve_mut","","Convert the `Rawlink` into an Option value",3,{"inputs":[{"name":"rawlink"}],"output":{"name":"option"}}],[11,"take","","Return the `Rawlink` and replace with `Rawlink::none()`",3,{"inputs":[{"name":"rawlink"}],"output":{"name":"rawlink"}}],[11,"from","","",3,{"inputs":[{"name":"rawlink"},{"name":"link"}],"output":{"name":"self"}}],[11,"clone","","",3,{"inputs":[{"name":"rawlink"}],"output":{"name":"rawlink"}}],[11,"new","","",4,{"inputs":[{"name":"node"},{"name":"t"}],"output":{"name":"node"}}],[11,"set_next","","Update the `prev` link on `next`, then set self's next pointer.",4,{"inputs":[{"name":"node"},{"name":"box"}],"output":null}],[11,"push_front_node","","Add a Node first in the list",2,{"inputs":[{"name":"linkedlist"},{"name":"box"}],"output":null}],[11,"pop_front_node","","Remove the first Node and return it, or None if the list is empty",2,{"inputs":[{"name":"linkedlist"}],"output":{"name":"option"}}],[11,"push_back_node","","Add a Node last in the list",2,{"inputs":[{"name":"linkedlist"},{"name":"box"}],"output":null}],[11,"pop_back_node","","Remove the last Node and return it, or None if the list is empty",2,{"inputs":[{"name":"linkedlist"}],"output":{"name":"option"}}],[11,"default","","",2,{"inputs":[{"name":"linkedlist"}],"output":{"name":"linkedlist"}}],[11,"new","","Creates an empty `LinkedList`.",2,{"inputs":[{"name":"linkedlist"}],"output":{"name":"linkedlist"}}],[11,"append","","Moves all elements from `other` to the end of the list.",2,{"inputs":[{"name":"linkedlist"},{"name":"linkedlist"}],"output":null}],[11,"iter","","Provides a forward iterator.",2,{"inputs":[{"name":"linkedlist"}],"output":{"name":"iter"}}],[11,"iter_mut","","Provides a forward iterator with mutable references.",2,{"inputs":[{"name":"linkedlist"}],"output":{"name":"itermut"}}],[11,"is_empty","","Returns `true` if the `LinkedList` is empty.",2,{"inputs":[{"name":"linkedlist"}],"output":{"name":"bool"}}],[11,"len","","Returns the length of the `LinkedList`.",2,{"inputs":[{"name":"linkedlist"}],"output":{"name":"usize"}}],[11,"clear","","Removes all elements from the `LinkedList`.",2,{"inputs":[{"name":"linkedlist"}],"output":null}],[11,"front","","Provides a reference to the front element, or `None` if the list is\nempty.",2,{"inputs":[{"name":"linkedlist"}],"output":{"name":"option"}}],[11,"front_mut","","Provides a mutable reference to the front element, or `None` if the list\nis empty.",2,{"inputs":[{"name":"linkedlist"}],"output":{"name":"option"}}],[11,"back","","Provides a reference to the back element, or `None` if the list is\nempty.",2,{"inputs":[{"name":"linkedlist"}],"output":{"name":"option"}}],[11,"back_mut","","Provides a mutable reference to the back element, or `None` if the list\nis empty.",2,{"inputs":[{"name":"linkedlist"}],"output":{"name":"option"}}],[11,"push_front","","Adds an element first in the list.",2,{"inputs":[{"name":"linkedlist"},{"name":"t"}],"output":null}],[11,"pop_front","","Removes the first element and returns it, or `None` if the list is\nempty.",2,{"inputs":[{"name":"linkedlist"}],"output":{"name":"option"}}],[11,"push_back","","Appends an element to the back of a list",2,{"inputs":[{"name":"linkedlist"},{"name":"t"}],"output":null}],[11,"pop_back","","Removes the last element from a list and returns it, or `None` if\nit is empty.",2,{"inputs":[{"name":"linkedlist"}],"output":{"name":"option"}}],[11,"split_off","","Splits the list into two at the given index. Returns everything after the given index,\nincluding the index.",2,{"inputs":[{"name":"linkedlist"},{"name":"usize"}],"output":{"name":"linkedlist"}}],[11,"drop","","",2,{"inputs":[{"name":"linkedlist"}],"output":null}],[11,"next","","",5,{"inputs":[{"name":"iter"}],"output":{"name":"option"}}],[11,"size_hint","","",5,null],[11,"next_back","","",5,{"inputs":[{"name":"iter"}],"output":{"name":"option"}}],[11,"next","","",6,{"inputs":[{"name":"itermut"}],"output":{"name":"option"}}],[11,"size_hint","","",6,null],[11,"next_back","","",6,{"inputs":[{"name":"itermut"}],"output":{"name":"option"}}],[11,"insert_next_node","","",6,{"inputs":[{"name":"itermut"},{"name":"box"}],"output":null}],[11,"insert_next","","Inserts `elt` just after the element most recently returned by `.next()`.\nThe inserted element does not appear in the iteration.",6,{"inputs":[{"name":"itermut"},{"name":"a"}],"output":null}],[11,"peek_next","","Provides a reference to the next element, without changing the iterator.",6,{"inputs":[{"name":"itermut"}],"output":{"name":"option"}}],[11,"next","","",7,{"inputs":[{"name":"intoiter"}],"output":{"name":"option"}}],[11,"size_hint","","",7,null],[11,"next_back","","",7,{"inputs":[{"name":"intoiter"}],"output":{"name":"option"}}],[11,"from_iter","","",2,{"inputs":[{"name":"linkedlist"},{"name":"t"}],"output":{"name":"linkedlist"}}],[11,"into_iter","","Consumes the list into an iterator yielding elements by value.",2,{"inputs":[{"name":"linkedlist"}],"output":{"name":"intoiter"}}],[11,"extend","","",2,{"inputs":[{"name":"linkedlist"},{"name":"t"}],"output":null}],[11,"extend","","",2,{"inputs":[{"name":"linkedlist"},{"name":"i"}],"output":null}],[11,"eq","","",2,{"inputs":[{"name":"linkedlist"},{"name":"linkedlist"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"linkedlist"},{"name":"linkedlist"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",2,{"inputs":[{"name":"linkedlist"},{"name":"linkedlist"}],"output":{"name":"option"}}],[11,"cmp","","",2,{"inputs":[{"name":"linkedlist"},{"name":"linkedlist"}],"output":{"name":"ordering"}}],[11,"clone","","",2,{"inputs":[{"name":"linkedlist"}],"output":{"name":"linkedlist"}}],[11,"fmt","","",2,{"inputs":[{"name":"linkedlist"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hash","","",2,{"inputs":[{"name":"linkedlist"},{"name":"h"}],"output":null}],[0,"static_linked_list","os1","A doubly-linked list with owned nodes modified slightly from the std library.\nThis version can be used in statics and has a const constructor.",null,null],[3,"StaticLinkedList","os1::static_linked_list","A doubly-linked list.",null,null],[12,"length","","",8,null],[12,"list_head","","",8,null],[12,"list_tail","","",8,null],[3,"Rawlink","","",null,null],[12,"p","","",9,null],[3,"Node","","",null,null],[12,"next","","",10,null],[12,"prev","","",10,null],[12,"value","","",10,null],[3,"Iter","","An iterator over references to the items of a `StaticLinkedList`.",null,null],[12,"head","","",11,null],[12,"tail","","",11,null],[12,"nelem","","",11,null],[3,"IterMut","","An iterator over mutable references to the items of a `StaticLinkedList`.",null,null],[12,"list","","",12,null],[12,"head","","",12,null],[12,"tail","","",12,null],[12,"nelem","","",12,null],[3,"IntoIter","","An iterator over mutable references to the items of a `StaticLinkedList`.",null,null],[12,"list","","",13,null],[5,"link_no_prev","","Clear the .prev field on `next`, then return `Some(next)`",null,{"inputs":[{"name":"box"}],"output":{"name":"link"}}],[6,"Link","","",null,null],[11,"clone","","",11,{"inputs":[{"name":"iter"}],"output":{"name":"iter"}}],[11,"clone","","",13,{"inputs":[{"name":"intoiter"}],"output":{"name":"intoiter"}}],[11,"none","","Like Option::None for Rawlink",9,{"inputs":[{"name":"rawlink"}],"output":{"name":"rawlink"}}],[11,"some","","Like Option::Some for Rawlink",9,{"inputs":[{"name":"rawlink"},{"name":"t"}],"output":{"name":"rawlink"}}],[11,"resolve","","Convert the `Rawlink` into an Option value",9,{"inputs":[{"name":"rawlink"}],"output":{"name":"option"}}],[11,"resolve_mut","","Convert the `Rawlink` into an Option value",9,{"inputs":[{"name":"rawlink"}],"output":{"name":"option"}}],[11,"take","","Return the `Rawlink` and replace with `Rawlink::none()`",9,{"inputs":[{"name":"rawlink"}],"output":{"name":"rawlink"}}],[11,"from","","",9,{"inputs":[{"name":"rawlink"},{"name":"link"}],"output":{"name":"self"}}],[11,"clone","","",9,{"inputs":[{"name":"rawlink"}],"output":{"name":"rawlink"}}],[11,"new","","",10,{"inputs":[{"name":"node"},{"name":"t"}],"output":{"name":"node"}}],[11,"set_next","","Update the `prev` link on `next`, then set self's next pointer.",10,{"inputs":[{"name":"node"},{"name":"box"}],"output":null}],[11,"push_front_node","","Add a Node first in the list",8,{"inputs":[{"name":"staticlinkedlist"},{"name":"box"}],"output":null}],[11,"pop_front_node","","Remove the first Node and return it, or None if the list is empty",8,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"link"}}],[11,"push_back_node","","Add a Node last in the list",8,{"inputs":[{"name":"staticlinkedlist"},{"name":"box"}],"output":null}],[11,"pop_back_node","","Remove the last Node and return it, or None if the list is empty",8,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"link"}}],[11,"default","","",8,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"staticlinkedlist"}}],[11,"new","","Creates an empty `StaticLinkedList`.",8,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"staticlinkedlist"}}],[11,"append","","Moves all elements from `other` to the end of the list.",8,{"inputs":[{"name":"staticlinkedlist"},{"name":"staticlinkedlist"}],"output":null}],[11,"iter","","Provides a forward iterator.",8,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"iter"}}],[11,"iter_mut","","Provides a forward iterator with mutable references.",8,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"itermut"}}],[11,"is_empty","","Returns `true` if the `StaticLinkedList` is empty.",8,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"bool"}}],[11,"len","","Returns the length of the `StaticLinkedList`.",8,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"usize"}}],[11,"clear","","Removes all elements from the `StaticLinkedList`.",8,{"inputs":[{"name":"staticlinkedlist"}],"output":null}],[11,"front","","Provides a reference to the front element, or `None` if the list is\nempty.",8,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"option"}}],[11,"front_mut","","Provides a mutable reference to the front element, or `None` if the list\nis empty.",8,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"option"}}],[11,"back","","Provides a reference to the back element, or `None` if the list is\nempty.",8,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"option"}}],[11,"back_mut","","Provides a mutable reference to the back element, or `None` if the list\nis empty.",8,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"option"}}],[11,"push_front","","Adds an element first in the list.",8,{"inputs":[{"name":"staticlinkedlist"},{"name":"t"}],"output":null}],[11,"pop_front","","Removes the first element and returns it, or `None` if the list is\nempty.",8,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"option"}}],[11,"push_back","","Appends an element to the back of a list",8,{"inputs":[{"name":"staticlinkedlist"},{"name":"t"}],"output":null}],[11,"pop_back","","Removes the last element from a list and returns it, or `None` if\nit is empty.",8,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"option"}}],[11,"split_off","","Splits the list into two at the given index. Returns everything after the given index,\nincluding the index.",8,{"inputs":[{"name":"staticlinkedlist"},{"name":"usize"}],"output":{"name":"staticlinkedlist"}}],[11,"remove","","Removes the element at the given index and returns it.",8,{"inputs":[{"name":"staticlinkedlist"},{"name":"usize"}],"output":{"name":"t"}}],[11,"next","","",11,{"inputs":[{"name":"iter"}],"output":{"name":"option"}}],[11,"size_hint","","",11,null],[11,"next_back","","",11,{"inputs":[{"name":"iter"}],"output":{"name":"option"}}],[11,"next","","",12,{"inputs":[{"name":"itermut"}],"output":{"name":"option"}}],[11,"size_hint","","",12,null],[11,"next_back","","",12,{"inputs":[{"name":"itermut"}],"output":{"name":"option"}}],[11,"insert_next_node","","",12,{"inputs":[{"name":"itermut"},{"name":"box"}],"output":null}],[11,"insert_next","","Inserts `elt` just after the element most recently returned by `.next()`.\nThe inserted element does not appear in the iteration.",12,{"inputs":[{"name":"itermut"},{"name":"a"}],"output":null}],[11,"peek_next","","Provides a reference to the next element, without changing the iterator.",12,{"inputs":[{"name":"itermut"}],"output":{"name":"option"}}],[11,"next","","",13,{"inputs":[{"name":"intoiter"}],"output":{"name":"option"}}],[11,"size_hint","","",13,null],[11,"next_back","","",13,{"inputs":[{"name":"intoiter"}],"output":{"name":"option"}}],[11,"from_iter","","",8,{"inputs":[{"name":"staticlinkedlist"},{"name":"t"}],"output":{"name":"staticlinkedlist"}}],[11,"into_iter","","Consumes the list into an iterator yielding elements by value.",8,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"intoiter"}}],[11,"extend","","",8,{"inputs":[{"name":"staticlinkedlist"},{"name":"t"}],"output":null}],[11,"extend","","",8,{"inputs":[{"name":"staticlinkedlist"},{"name":"i"}],"output":null}],[11,"eq","","",8,{"inputs":[{"name":"staticlinkedlist"},{"name":"staticlinkedlist"}],"output":{"name":"bool"}}],[11,"ne","","",8,{"inputs":[{"name":"staticlinkedlist"},{"name":"staticlinkedlist"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",8,{"inputs":[{"name":"staticlinkedlist"},{"name":"staticlinkedlist"}],"output":{"name":"option"}}],[11,"cmp","","",8,{"inputs":[{"name":"staticlinkedlist"},{"name":"staticlinkedlist"}],"output":{"name":"ordering"}}],[11,"clone","","",8,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"staticlinkedlist"}}],[11,"fmt","","",8,{"inputs":[{"name":"staticlinkedlist"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hash","","",8,{"inputs":[{"name":"staticlinkedlist"},{"name":"h"}],"output":null}],[0,"concurrency","os1","A module for concurrency primitives",null,null],[3,"Semaphore","os1::concurrency","`Semaphore` is a much more Rustic semaphore. It returns an RAII\n`SemaphoreGuard`, which automatically calls \"up\" when it goes out of\nscope. This semaphore takes ownership of the data it is guarding, so that\nRust ownership and lifetime semantics can be used to guarantee safety of\nthe resource.",null,null],[12,"inner","","",14,null],[12,"data","","",14,null],[3,"StaticSemaphore","","`StaticSemaphore` is a semaphore implementation that can be used in\nstatics. It has a const constructor.",null,null],[12,"count","","",15,null],[12,"queue","","",15,null],[3,"SemaphoreGuard","","RAII SemaphoreGuard",null,null],[12,"semaphore","","",16,null],[12,"data","","",16,null],[3,"Barrier","","A Barrier implementation.",null,null],[12,"count","","",17,null],[12,"n","","",17,null],[12,"event","","",17,null],[3,"Event","","An Event data structure.",null,null],[12,"status","","",18,null],[0,"semaphore","","A semaphore implementation based on the rust Mutex<T> type",null,null],[3,"Semaphore","os1::concurrency::semaphore","`Semaphore` is a much more Rustic semaphore. It returns an RAII\n`SemaphoreGuard`, which automatically calls \"up\" when it goes out of\nscope. This semaphore takes ownership of the data it is guarding, so that\nRust ownership and lifetime semantics can be used to guarantee safety of\nthe resource.",null,null],[12,"inner","","",14,null],[12,"data","","",14,null],[3,"StaticSemaphore","","`StaticSemaphore` is a semaphore implementation that can be used in\nstatics. It has a const constructor.",null,null],[12,"count","","",15,null],[12,"queue","","",15,null],[3,"SemaphoreGuard","","RAII SemaphoreGuard",null,null],[12,"semaphore","","",16,null],[12,"data","","",16,null],[11,"new","os1::concurrency","Create a new semaphore with the the given count guarding the given value",14,{"inputs":[{"name":"semaphore"},{"name":"t"},{"name":"isize"}],"output":{"name":"semaphore"}}],[11,"down","","Acquire.\nreturns an RAII guard, so no need for up()",14,{"inputs":[{"name":"semaphore"}],"output":{"name":"semaphoreguard"}}],[11,"drop","","When the semaphore goes out of scope, it destroys the contents",14,{"inputs":[{"name":"semaphore"}],"output":null}],[11,"new","","Create a new `StaticSemaphore` with the given count",15,{"inputs":[{"name":"staticsemaphore"},{"name":"isize"}],"output":{"name":"staticsemaphore"}}],[11,"down","","Acquire",15,{"inputs":[{"name":"staticsemaphore"}],"output":null}],[11,"up","","Release",15,{"inputs":[{"name":"staticsemaphore"}],"output":null}],[11,"destroy","","Clean up.\nCannot implement Drop here because we want to be able\nto create a static semaphore.",15,{"inputs":[{"name":"staticsemaphore"}],"output":null}],[11,"new","","Create a guard referring to the given semaphore and data",16,{"inputs":[{"name":"semaphoreguard"},{"name":"staticsemaphore"},{"name":"unsafecell"}],"output":{"name":"semaphoreguard"}}],[11,"drop","","`SemaphoreGuard` is RAII, so dropping the guard calls up",16,{"inputs":[{"name":"semaphoreguard"}],"output":null}],[11,"deref","","",16,{"inputs":[{"name":"semaphoreguard"}],"output":{"name":"t"}}],[11,"deref_mut","","",16,{"inputs":[{"name":"semaphoreguard"}],"output":{"name":"t"}}],[0,"barrier","","A module containing a barrier implementation",null,null],[3,"Barrier","os1::concurrency::barrier","A Barrier implementation.",null,null],[12,"count","","",17,null],[12,"n","","",17,null],[12,"event","","",17,null],[11,"new","os1::concurrency","Create a new barrier for `n` processes",17,{"inputs":[{"name":"barrier"},{"name":"usize"}],"output":{"name":"barrier"}}],[11,"reach","","This process reaches the barrier",17,{"inputs":[{"name":"barrier"}],"output":null}],[0,"event","","A module containing an event implementation",null,null],[3,"Event","os1::concurrency::event","An Event data structure.",null,null],[12,"status","","",18,null],[11,"new","os1::concurrency","Creates a new `Event`",18,{"inputs":[{"name":"event"}],"output":{"name":"event"}}],[11,"wait","","Block this process until `notify` is called",18,{"inputs":[{"name":"event"}],"output":null}],[11,"notify","","Wake up all processes that called `wait` on this event",18,{"inputs":[{"name":"event"}],"output":null}],[11,"reset","","Reset the event before more processes can `wait`",18,{"inputs":[{"name":"event"}],"output":null}],[0,"fs","os1","A module for file system stuff",null,null],[5,"init","os1::fs","Initialize the file system",null,{"inputs":[],"output":null}],[0,"interrupts","os1","This module contains everything needed for interrupts",null,null],[5,"on","os1::interrupts","Turn interrupts on",null,{"inputs":[],"output":null}],[5,"off","","Turn interrupts off",null,{"inputs":[],"output":null}],[5,"add_trap_handler","","Register a trap handler for the given trap number with the given privelege level",null,null],[5,"init","","Initialize interrupts. Set the PIT frequency to `pit_hz`",null,{"inputs":[{"name":"usize"}],"output":null}],[0,"idt","","This module contains IDT stuff",null,null],[3,"TableDescriptor","os1::interrupts::idt","A descriptor for use in with instructions like `lgdt` or `lidt`",null,null],[12,"size","","",19,null],[12,"location","","",19,null],[3,"IDTDescr","","An entry in the IDT",null,null],[12,"offset_1","","",20,null],[12,"selector","","",20,null],[12,"zero","","",20,null],[12,"type_attr","","",20,null],[12,"offset_2","","",20,null],[5,"add_interrupt_handler","","Register an interrupt handler for the given IRQ number",null,null],[5,"add_trap_handler","","Register a trap handler for the given trap number with the given privelege level",null,null],[7,"kernelCodeSeg","","",null,null],[7,"idt","","",null,null],[11,"clone","","",19,{"inputs":[{"name":"tabledescriptor"}],"output":{"name":"tabledescriptor"}}],[11,"clone","","",20,{"inputs":[{"name":"idtdescr"}],"output":{"name":"idtdescr"}}],[11,"new","","Create an empty `IDTDescr`",20,{"inputs":[{"name":"idtdescr"}],"output":{"name":"idtdescr"}}],[11,"set_offset","","Set the offset of the descriptor to `offset`",20,{"inputs":[{"name":"idtdescr"},{"name":"u32"}],"output":null}],[11,"set_type_attr","","Set the type and attributes of the descriptor",20,{"inputs":[{"name":"idtdescr"},{"name":"bool"},{"name":"u8"},{"name":"bool"},{"name":"u8"}],"output":null}],[11,"set_selector","","Set the segment selector of the descriptor",20,{"inputs":[{"name":"idtdescr"},{"name":"u16"}],"output":null}],[0,"process","os1::interrupts","Module for cleanly turning interrupts on and off",null,null],[5,"on","os1::interrupts::process","Turn interrupts on",null,{"inputs":[],"output":null}],[5,"off","","Turn interrupts off",null,{"inputs":[],"output":null}],[5,"start_irq","","Helper method for use in IRQ\nBookkeeping to start an irq.\nThis should never happen if there is no current process.",null,{"inputs":[],"output":null}],[5,"end_irq","","Helper method for use in IRQ\nBookkeeping to end an irq",null,{"inputs":[],"output":null}],[0,"pit","os1::interrupts","A module for the programmable interrupt timer",null,null],[5,"init","os1::interrupts::pit","Initialize the PIT to the given frequency",null,{"inputs":[{"name":"usize"}],"output":null}],[5,"handler","","Handle a PIT interrupt. Increments `JIFFIES`",null,{"inputs":[],"output":null}],[5,"seconds","","Calculate the number of seconds since boot",null,{"inputs":[],"output":{"name":"usize"}}],[7,"hz","","The frequency of the PIT",null,null],[7,"JIFFIES","","The number of jiffies passed since boot",null,null],[17,"FREQ","","Max frequency of the PIT",null,null],[0,"pic","os1::interrupts","A module for programmable interrupt controller",null,null],[5,"init","os1::interrupts::pic","Initialize the PIC, but leave interrupts disabled",null,{"inputs":[],"output":null}],[5,"pic_eoi","","End of interrupt: send the next irq, but interrupts still disabled",null,{"inputs":[{"name":"u8"}],"output":null}],[5,"pic_irq","","Rust-side IRQ handling code",null,{"inputs":[{"name":"usize"}],"output":null}],[17,"C1","","Command port for PIC1",null,null],[17,"D1","","Data port for PIC1",null,null],[17,"C2","","Command port for PIC2",null,null],[17,"D2","","Data port for PIC2",null,null],[17,"FIRST_IDT","","First IRQ number allowed for registering handlers",null,null],[0,"machine","os1","This is the Rust-side handle for assembly code. Most of the FFI handles are\nin this module.",null,null],[5,"inb","os1::machine","a wrapper around inb",null,null],[5,"inl","","a wrapper around inl",null,null],[5,"outb","","a wrapper around outb",null,null],[5,"ltr","","a wrapper around ltr",null,null],[5,"pit_do_init","","Initialize the PIT with the given divide",null,null],[5,"vmm_on","","Turn on VM and load cr3 with the given value",null,null],[5,"invlpg","","Flush the page from the TLB",null,null],[5,"cli","","a wrapper around cli",null,null],[5,"sti","","a wrapper around sti",null,null],[5,"irq0","","A handler for IRQ 0",null,null],[5,"irq1","","A handler for IRQ 1",null,null],[5,"irq2","","A handler for IRQ 2",null,null],[5,"irq3","","A handler for IRQ 3",null,null],[5,"irq4","","A handler for IRQ 4",null,null],[5,"irq5","","A handler for IRQ 5",null,null],[5,"irq6","","A handler for IRQ 6",null,null],[5,"irq7","","A handler for IRQ 7",null,null],[5,"irq8","","A handler for IRQ 8",null,null],[5,"irq9","","A handler for IRQ 9",null,null],[5,"irq10","","A handler for IRQ 10",null,null],[5,"irq11","","A handler for IRQ 11",null,null],[5,"irq12","","A handler for IRQ 12",null,null],[5,"irq13","","A handler for IRQ 13",null,null],[5,"irq14","","A handler for IRQ 14",null,null],[5,"irq15","","A handler for IRQ 15",null,null],[5,"proc_yield","","An unsafe proc_yield handle that saves the context of the current\nprocess before switching. *Do not* call this function directly! Instead,\nuse `process::proc_yield`, which is a wrapper around this function.",null,null],[5,"context_switch","","Do a context switch to `next_context` with the eflags register set to\n`eflags`. This function is called by `process::proc_yield`",null,null],[5,"eflags","","Returns the value of eflags",null,null],[5,"page_fault_handler","","The assembly handle for the page fault handler. This function calls\n`vmm_page_fault`.",null,null],[0,"memory","os1","This module contains everything that has to do with memory",null,null],[3,"AddressSpace","os1::memory","The address space of a single process",null,null],[12,"page_dir","","paddr of this addr space's PD",21,null],[12,"kmap_index","","the index of the first un-kmapped page",21,null],[12,"lock","","a lock for the address space",21,null],[12,"req_pid","","The PID of the process the current share request is going to",21,null],[12,"req_paddr","","The frame the current share request is for",21,null],[12,"req_bar","","A barrier for page-sharing",21,null],[12,"req_wait","","A waiting list for other processes who are expecting this\nprocess to share with them",21,null],[5,"vmm_page_fault","","The Rust-side code of the page fault handler.",null,{"inputs":[{"name":"usize"}],"output":null}],[5,"esp0","","",null,{"inputs":[{"name":"usize"}],"output":null}],[5,"init","","Initialize all memory subsystems",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":null}],[0,"rust_alloc","","This module contains the outside interface with the kernels memory allocator.\nrustc will look for these functions.",null,null],[5,"__rust_allocate","os1::memory::rust_alloc","Return a pointer to `size` bytes of memory aligned to `align`.",null,null],[5,"__rust_deallocate","","Deallocates the memory referenced by `ptr`.",null,null],[5,"__rust_reallocate","","Resize the allocation referenced by `ptr` to `size` bytes.",null,null],[5,"__rust_reallocate_inplace","","Resize the allocation referenced by `ptr` to `size` bytes.",null,null],[5,"__rust_usable_size","","Returns the usable size of an allocation created with the specified the\n`size` and `align`.",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"usize"}}],[5,"__rust_stats_print","","Prints implementation-defined allocator statistics.",null,{"inputs":[],"output":null}],[0,"heap","os1::memory","This file contains the memory allocator used by the rust_alloc module",null,null],[3,"Block","os1::memory::heap","A struct representing a heap block.",null,null],[5,"round_to_block_align","","Round up to the nearest multiple of `BLOCK_ALIGN`",null,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[5,"round_to_n","","Round the size to `n`. `n` must be a power of 2",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"usize"}}],[5,"init","","Initialize the kernel heap",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":null}],[5,"malloc","","Return a pointer to `size` bytes of memory aligned to `align`.",null,null],[5,"free","","Deallocates the memory referenced by `ptr`.",null,null],[5,"usable_size","","Returns the usable size of an allocation created with the specified the\n`size` and `align`.",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"usize"}}],[5,"print_stats","","Prints implementation-defined allocator statistics.",null,{"inputs":[],"output":null}],[5,"get_block_stats","","Helper method to compute stats",null,null],[7,"BLOCK_ALIGN","","A const representing the minimum alignment of any block.\nIt is effectively a const, but it has to be initialized at startup because `size_of` is\nnon-const.",null,null],[7,"START","","The start address of the kernel heap",null,null],[7,"END","","The end address of the kernel heap. That is, the first address that is not in the heap.",null,null],[7,"free_list","","A pointer to the first free heap block",null,null],[7,"SUCC_MALLOCS","","The number of successful mallocs (for stats purposes)",null,null],[7,"FAIL_MALLOCS","","The number of unsuccessful mallocs (for stats purposes)",null,null],[7,"FREES","","The number of successful frees (for stats purposes)",null,null],[17,"DEBUG","","A flag to turn on and off debugging output",null,null],[11,"get_head","","Returns the first word of the block, which will contain the size if this is a free block",22,{"inputs":[{"name":"block"}],"output":{"name":"usize"}}],[11,"set_head","","Sets the header to the given value",22,{"inputs":[{"name":"block"},{"name":"usize"}],"output":null}],[11,"get_foot","","Returns the last word of the block, which will contain the size if this is a free block",22,{"inputs":[{"name":"block"}],"output":{"name":"usize"}}],[11,"set_foot","","Sets the footer to the given value",22,{"inputs":[{"name":"block"},{"name":"usize"}],"output":null}],[11,"get_free_bits","","Gets the 4 free bits of the block",22,{"inputs":[{"name":"block"}],"output":{"name":"u8"}}],[11,"set_next","","Set the forward pointer (but not the free bits)",22,null],[11,"set_prev","","Set the backward pointer",22,null],[11,"is_free","","Returns true if the block is a valid free block.\nThis method does a lot of sanity checiking",22,{"inputs":[{"name":"block"}],"output":{"name":"bool"}}],[11,"mark_free","","Set the free bits",22,{"inputs":[{"name":"block"}],"output":null}],[11,"mark_used","","Clear the free bits.\nThe block should already be removed from the free list",22,{"inputs":[{"name":"block"}],"output":null}],[11,"get_size","","Return the size of the block (user-usable data size)",22,{"inputs":[{"name":"block"}],"output":{"name":"usize"}}],[11,"set_size","","Set the size of block",22,{"inputs":[{"name":"block"},{"name":"usize"}],"output":null}],[11,"get_contiguous_next","","Returns the heap block immediately following this one",22,null],[11,"get_contiguous_prev","","Returns the heap block immediately preceding this one\nor null if there is no valid previous block.",22,null],[11,"get_free_next","","Returns the forward ptr of the block (excluding the free bits)",22,null],[11,"get_free_prev","","Returns the backward ptr of the block",22,null],[11,"remove","","Remove from free list. Clear forward/backward pointers",22,{"inputs":[{"name":"block"}],"output":null}],[11,"insert","","Add to head of free list",22,{"inputs":[{"name":"block"}],"output":null}],[11,"merge_with_next","","Merge this block with the next block.\nRemoves the second block from the free list before merging",22,{"inputs":[{"name":"block"}],"output":null}],[11,"split","","Split the block so that it is the given size.\nInsert the new block into the free list.\nThe block must be large enough to split (`>= 2*BLOCK_ALIGN`).\nThe block must be free.\nThe new size must be a multiple of `BLOCK_ALIGN`.",22,{"inputs":[{"name":"block"},{"name":"usize"}],"output":null}],[11,"is_match","","Returns true if this block matches the size and alignment.\nReturns the size at which the block should be split to obtain\nan aligned block; the second return value is meaningless if\nwe return false.",22,null],[0,"tss","os1::memory","",null,null],[3,"TSSDescriptor","os1::memory::tss","",null,null],[12,"f0","","",23,null],[12,"f1","","",23,null],[3,"TSS","","",null,null],[12,"prev","","",24,null],[12,"esp0","","",24,null],[12,"ss0","","",24,null],[12,"esp1","","",24,null],[12,"ss1","","",24,null],[12,"esp2","","",24,null],[12,"ss2","","",24,null],[12,"unused","","",24,null],[5,"init","","",null,{"inputs":[],"output":null}],[5,"esp0","","",null,{"inputs":[{"name":"usize"}],"output":null}],[7,"tssDescriptor","","",null,null],[7,"tssDS","","",null,null],[7,"kernelDataSeg","","",null,null],[7,"TSS_","","",null,null],[11,"set","","",23,{"inputs":[{"name":"tssdescriptor"},{"name":"tss"},{"name":"usize"}],"output":null}],[11,"new","","",24,{"inputs":[{"name":"tss"}],"output":{"name":"tss"}}],[11,"esp0","","",24,{"inputs":[{"name":"tss"},{"name":"usize"}],"output":null}],[0,"physmem","os1::memory","Physical memory management",null,null],[3,"Frame","os1::memory::physmem","A physical memory frame",null,null],[12,"mem","","",25,null],[3,"FrameInfoSection","","Should take up 4MiB on a 32-bit machine.\nThere is one frame info for each frame, associated by frame index",null,null],[12,"arr","","",26,null],[3,"FrameInfo","","Frame info\n```\nWhen free\n31                 20           0\n[nnnnnnnnnnnnnnnnnnnn           1]\n ^-- next free index            ^-- free bit",null,null],[12,"info","","",27,null],[3,"SharedFrameInfo","","A struct to keep track of information related to shared\nphysical frames.",null,null],[12,"pad","","needs to be at least 4B aligned",28,null],[12,"list","","list of sharers: (pid, vaddr)",28,null],[5,"init","","Initialize physical memory frames using the rest of physical memory.\nThis function detects all available physical memory.",null,{"inputs":[{"name":"usize"}],"output":null}],[7,"FRAME_INFO","","Array of `FrameInfo`. This is a pointer to the region of memory used\nto hold physical memory allocation metadata.",null,null],[7,"FREE_FRAMES","","The index of the first free frame in a LIFO list.\n0 => empty list",null,null],[11,"alloc","","Allocate a frame and return its physical address",25,{"inputs":[{"name":"frame"}],"output":{"name":"usize"}}],[11,"free","","Free the frame with the given index",25,{"inputs":[{"name":"frame"},{"name":"usize"}],"output":null}],[11,"share","","Add the given pid as a sharer of this frame.",25,{"inputs":[{"name":"frame"},{"name":"usize"},{"name":"usize"},{"name":"usize"}],"output":null}],[11,"index","","",25,{"inputs":[{"name":"frame"},{"name":"usize"}],"output":{"name":"usize"}}],[11,"index_mut","","",25,{"inputs":[{"name":"frame"},{"name":"usize"}],"output":{"name":"usize"}}],[11,"index","","",26,{"inputs":[{"name":"frameinfosection"},{"name":"usize"}],"output":{"name":"frameinfo"}}],[11,"index_mut","","",26,{"inputs":[{"name":"frameinfosection"},{"name":"usize"}],"output":{"name":"frameinfo"}}],[11,"alloc","","Allocate the frame referred to by this `FrameInfo`.\nNOTE: this should only be called on the first frame in the free list",27,{"inputs":[{"name":"frameinfo"}],"output":null}],[11,"free","","Free the frame referred to by this FrameInfo\nif this is the last sharere; otherwise, just remove this\nprocess's `SharedFrameInfo`.",27,{"inputs":[{"name":"frameinfo"}],"output":null}],[11,"get_index","","Get the index of the `Frame`",27,{"inputs":[{"name":"frameinfo"}],"output":{"name":"usize"}}],[11,"set_free","","Set the free bit of this `FrameInfo` to 1 if `free` is true; else 0",27,{"inputs":[{"name":"frameinfo"},{"name":"bool"}],"output":null}],[11,"get_next_free","","Get the index of the next free frame",27,{"inputs":[{"name":"frameinfo"}],"output":{"name":"usize"}}],[11,"set_next_free","","Set the index of the next free frame",27,{"inputs":[{"name":"frameinfo"},{"name":"usize"}],"output":null}],[11,"has_shared_info","","Returns true if this frame has shared frame info.",27,{"inputs":[{"name":"frameinfo"}],"output":{"name":"bool"}}],[11,"get_shared_info","","Get the `SharedFrameInfo` of this frame",27,{"inputs":[{"name":"frameinfo"}],"output":{"name":"option"}}],[11,"set_shared_info","","Set the `SharedFrameInfo` of this frame",27,null],[11,"clear_shared_info","","Remove the `SharedFrameInfo` ptr of the frame",27,{"inputs":[{"name":"frameinfo"}],"output":null}],[11,"new","","",28,{"inputs":[{"name":"sharedframeinfo"}],"output":{"name":"sharedframeinfo"}}],[0,"vm","os1::memory","A module for virtual memory management",null,null],[3,"AddressSpace","os1::memory::vm","The address space of a single process",null,null],[12,"page_dir","","paddr of this addr space's PD",21,null],[12,"kmap_index","","the index of the first un-kmapped page",21,null],[12,"lock","","a lock for the address space",21,null],[12,"req_pid","","The PID of the process the current share request is going to",21,null],[12,"req_paddr","","The frame the current share request is for",21,null],[12,"req_bar","","A barrier for page-sharing",21,null],[12,"req_wait","","A waiting list for other processes who are expecting this\nprocess to share with them",21,null],[5,"vmm_page_fault","","The Rust-side code of the page fault handler.",null,{"inputs":[{"name":"usize"}],"output":null}],[5,"init_shared_pdes","","Create `n` PDEs to direct map the memory start from the `i`th page.\nunsafe because it deals with raw pointers and static muts.",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":null}],[5,"init","","Initialize virtual memory management but do not turn on VM.",null,{"inputs":[{"name":"usize"}],"output":null}],[0,"structs","","A module containing useful structs to abstract paging structures",null,null],[3,"PagingEntry","os1::memory::vm::structs","A single entry in a page directory or table\n```\n31                 12  9       0\n[                    000 flags  ]\n```",null,null],[12,"entry","","",29,null],[3,"VMTable","","An abstraction of page directories and page tables",null,null],[12,"entries","","",30,null],[11,"clone","","",29,{"inputs":[{"name":"pagingentry"}],"output":{"name":"pagingentry"}}],[11,"new","","Get a blank entry",29,{"inputs":[{"name":"pagingentry"}],"output":{"name":"pagingentry"}}],[11,"set_present","","Set the present bit.\ntrue = present; false = not present",29,{"inputs":[{"name":"pagingentry"},{"name":"bool"}],"output":null}],[11,"set_read_write","","Set the read/write bit.\ntrue = read/write, false = read-only",29,{"inputs":[{"name":"pagingentry"},{"name":"bool"}],"output":null}],[11,"set_privelege_level","","Set the privelege level bit.\ntrue = all, false = kernel mode only",29,{"inputs":[{"name":"pagingentry"},{"name":"bool"}],"output":null}],[11,"set_caching","","Set caching bit.\ntrue = write-through, false = write-back",29,{"inputs":[{"name":"pagingentry"},{"name":"bool"}],"output":null}],[11,"set_flag","","Set the `index`-th flag to `value`.\ntrue = 1; false = 0",29,{"inputs":[{"name":"pagingentry"},{"name":"u8"},{"name":"bool"}],"output":null}],[11,"set_address","","Set the upper 20 bits of the entry to the upper 20 bits of `address`",29,{"inputs":[{"name":"pagingentry"},{"name":"usize"}],"output":null}],[11,"is_flag","","Return true if the `index`-th bit is set",29,{"inputs":[{"name":"pagingentry"},{"name":"u8"}],"output":{"name":"bool"}}],[11,"get_address","","Return the upper 20-bits of the entry",29,{"inputs":[{"name":"pagingentry"}],"output":{"name":"usize"}}],[11,"free","","Free the frame pointed to if `dealloc` and mark this entry not present.",29,{"inputs":[{"name":"pagingentry"},{"name":"bool"}],"output":null}],[11,"new","","Returns a reference to a new `VMTable` and its physical address.\nThe new table is kmapped if necessary, and is always cleared.",30,null],[11,"index","","",30,{"inputs":[{"name":"vmtable"},{"name":"usize"}],"output":{"name":"pagingentry"}}],[11,"index_mut","","",30,{"inputs":[{"name":"vmtable"},{"name":"usize"}],"output":{"name":"pagingentry"}}],[0,"addr_space","os1::memory::vm","A module process address spaces",null,null],[3,"AddressSpace","os1::memory::vm::addr_space","The address space of a single process",null,null],[12,"page_dir","","paddr of this addr space's PD",21,null],[12,"kmap_index","","the index of the first un-kmapped page",21,null],[12,"lock","","a lock for the address space",21,null],[12,"req_pid","","The PID of the process the current share request is going to",21,null],[12,"req_paddr","","The frame the current share request is for",21,null],[12,"req_bar","","A barrier for page-sharing",21,null],[12,"req_wait","","A waiting list for other processes who are expecting this\nprocess to share with them",21,null],[5,"vmm_page_fault","","The Rust-side code of the page fault handler.",null,{"inputs":[{"name":"usize"}],"output":null}],[11,"new","os1::memory","Create a new address space and set up the PD.",21,{"inputs":[{"name":"addressspace"}],"output":{"name":"addressspace"}}],[11,"map","","Map `virt` to `phys` in the address space. The method first\ntries to acquire the address space lock if `lock` is true.",21,{"inputs":[{"name":"addressspace"},{"name":"usize"},{"name":"usize"},{"name":"bool"}],"output":null}],[11,"kmap","","Map the given `paddr` for temporary use by the kernel and return a mut reference to the\nframe.\nNOTE: should only be called on the current address space because it assumes that the PD is\nat PD_ADDRESS",21,{"inputs":[{"name":"addressspace"},{"name":"usize"}],"output":{"name":"frame"}}],[11,"unmap","","Remove any mapping for this virtual address. The method first tries to acquire the address\nspace lock if `lock` is true.",21,{"inputs":[{"name":"addressspace"},{"name":"usize"},{"name":"bool"}],"output":null}],[11,"v_to_p","","Returns the current physical address mapped to the given virtual address\nor None if it is not mapped. The method first tries to acquire the address\nspace lock if `lock` is true.",21,{"inputs":[{"name":"addressspace"},{"name":"usize"},{"name":"bool"}],"output":{"name":"option"}}],[11,"activate","","Activate the current address space and turn on VM if needed",21,{"inputs":[{"name":"addressspace"}],"output":null}],[11,"request_share","","Send a page-share request to the process with PID `pid` for\nthe frame mapped to `vaddr` in this address space.",21,{"inputs":[{"name":"addressspace"},{"name":"usize"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"accept_share","","Creates a mapping in this process's address space for the\nfirst page-share request from the process with the given PID\nto the given page.",21,{"inputs":[{"name":"addressspace"},{"name":"usize"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"clear","","Remove all non-kernel mappings in this address space.\nNOTE: must run while this address space is active",21,{"inputs":[{"name":"addressspace"}],"output":null}],[11,"drop","","Deallocate the page directory.\nNOTE: cannot run while the address space is active",21,{"inputs":[{"name":"addressspace"}],"output":null}],[7,"SHARED_PDES","os1::memory::vm","A list of shared PDEs direct mapping the beginning of memory",null,null],[7,"NUM_SHARED","","The number of shared PDEs (for convenience)",null,null],[7,"PD_ADDRESS","","The virtual address to which the PD is mapped",null,null],[7,"KMAP_ADDRESS","","The beginning of kmap memory",null,null],[7,"USER_ADDRESS","","The beginning of user memory",null,null],[7,"VMM_ON","","Is VM on?",null,null],[0,"regionmap","os1::memory","Module for detecting available physical memory",null,null],[3,"MemoryListEntry","os1::memory::regionmap","Represents an entry in the list of memory regions generated by the E820\nBIOS call.",null,null],[12,"base_l","","",31,null],[12,"base_h","","",31,null],[12,"length_l","","",31,null],[12,"length_h","","",31,null],[12,"region_type","","",31,null],[12,"acpi","","",31,null],[3,"Region","","Represents a region of memory",null,null],[12,"start","","",32,null],[12,"end","","",32,null],[12,"usable","","",32,null],[3,"RegionMap","","Represents a map of memory regions",null,null],[12,"list","","",33,null],[12,"index","","",33,null],[5,"find","","Find the length and type of the most restrictive\nmapping for `addr` based on the E820 BIOS call",null,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[5,"find_next","","Find the beginning address of the next region of memory\nbased on the E820 BIOS call",null,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[7,"memory_map_count","","",null,null],[7,"memory_map","","",null,null],[11,"dump","","Print this region for debugging purposes",32,{"inputs":[{"name":"region"}],"output":null}],[11,"new","","Produce a map of all memory after start.\nThis is a 32-bit OS, so we only have to deal with 4GB",33,null],[11,"dump","","Print out the memory map for debugging purposes",33,{"inputs":[{"name":"regionmap"}],"output":null}],[11,"next","","Returns the index of the next avail frame and number of\navailable frames OR None if there aren't any more.",33,{"inputs":[{"name":"regionmap"}],"output":{"name":"option"}}],[0,"process","os1","A module for process management",null,null],[3,"Process","os1::process","Represents a single process, its identity, resources, etc.",null,null],[12,"name","","Name of the process; not necessarily unique",34,null],[12,"pid","","Unique 32-bit identifier",34,null],[12,"run","","The routine of the process",34,null],[12,"state","","The current state of the process",34,null],[12,"stack","","A pointer to the kheap-allocated stack space for this process's\nkernel stack. This pointer is to the bottom of the stack, not the head.",34,null],[12,"kcontext","","The saved kernel context for context switching",34,null],[12,"addr_space","","The virtual memory address space of the process",34,null],[12,"disable_cnt","","Number of calls to interrupts::on() while this process was running\nInterrupts are on if `disable_cnt == 0`",34,null],[4,"State","","An enum representing the possible states of a process",null,null],[13,"INIT","","Process is created, but not ready",35,null],[13,"READY","","Process is in the ready q",35,null],[13,"RUNNING","","Process is running (not on the ready q or blocked)",35,null],[13,"BLOCKED","","Process is blocked on a q",35,null],[13,"TERMINATED","","Process has died",35,null],[5,"init","","Initialize the process subsystem.\nThis creates the init, idle, and reaper processes, but does not\nstart any of them yet.",null,{"inputs":[],"output":null}],[5,"start_proc","","The entry point of all processes",null,{"inputs":[],"output":null}],[5,"proc_yield","","A safe wrapper around machine::proc_yield.",null,{"inputs":[{"name":"option"}],"output":null}],[5,"_proc_yield","","The unsafe function that does the actual work of choosing the\nnext process and switching to it.",null,{"inputs":[{"name":"option"}],"output":null}],[5,"exit","","Called by the current process to exit with the given exit code",null,{"inputs":[{"name":"usize"}],"output":null}],[0,"context","","A module for saving a process's context",null,null],[3,"KContext","os1::process::context","A struct representing the contents of the general purpose registers\nas produced by the `pusha` instruction.",null,null],[12,"edi","","",36,null],[12,"esi","","",36,null],[12,"ebp","","",36,null],[12,"esp","","",36,null],[12,"ebx","","",36,null],[12,"edx","","",36,null],[12,"ecx","","",36,null],[12,"eax","","",36,null],[5,"store_kcontext","","Save the `KContext` of the current process to its process struct",null,null],[11,"clone","","",36,{"inputs":[{"name":"kcontext"}],"output":{"name":"kcontext"}}],[11,"new","","Create a new empty context struct",36,{"inputs":[{"name":"kcontext"}],"output":{"name":"kcontext"}}],[0,"ready_queue","os1::process","A module for the ready queue",null,null],[5,"make_ready","os1::process::ready_queue","Add the process to the ready queue",null,null],[5,"get_next","","Unqueue and return the next ready process.\nNOTE: returns null if there are no ready processes",null,null],[7,"READY_QUEUE","","The ready queue. A queue containing all processes that are ready to be scheduled.",null,null],[0,"proc_table","os1::process","A module for the process table, a table mapping each PID to a process struct",null,null],[3,"ProcessTable","os1::process::proc_table","A process table implemented as an indexable deque",null,null],[12,"pt_head","","",37,null],[12,"first_pid","","",37,null],[12,"capacity","","",37,null],[12,"size","","",37,null],[3,"ProcessTableNode","","A single node in the `ProcessTable`, holding mappings\nfor `NODE_SIZE` processes",null,null],[12,"map","","",38,null],[12,"next","","",38,null],[7,"PROCESS_TABLE","","The process table for the kernel",null,null],[7,"TABLE_LOCK","","A lock for the `PROCESS_TABLE`",null,null],[17,"NODE_SIZE","","Number of PIDs mapped by a single `ProcessTableNode`",null,null],[11,"new","","",37,{"inputs":[{"name":"processtable"}],"output":{"name":"processtable"}}],[11,"push","","Add the new process to the end of the Table. Since processes\nare created with sequential PIDs, we already know the PID.",37,null],[11,"remove","","Void the entry in the table. This should be done just before\ndeallocating the process.",37,{"inputs":[{"name":"processtable"},{"name":"usize"}],"output":null}],[11,"get","","Get the process with the matching PID",37,{"inputs":[{"name":"processtable"},{"name":"usize"}],"output":{"name":"option"}}],[11,"free","","Free as many `ProcessTableNode`s as possible",37,{"inputs":[{"name":"processtable"}],"output":null}],[11,"get_node","","Get the node containing the given PID",37,{"inputs":[{"name":"processtable"},{"name":"usize"}],"output":{"name":"processtablenode"}}],[11,"get_node_mut","","Get the node containing the given PID",37,{"inputs":[{"name":"processtable"},{"name":"usize"}],"output":{"name":"processtablenode"}}],[11,"get_last_node","","Get the last node in the table",37,{"inputs":[{"name":"processtable"}],"output":{"name":"processtablenode"}}],[11,"new","","",38,null],[11,"destroy","","",38,null],[11,"is_empty","","",38,{"inputs":[{"name":"processtablenode"}],"output":{"name":"bool"}}],[11,"index","","",38,null],[11,"index_mut","","",38,null],[0,"init","os1::process","A module for the init process",null,null],[5,"run","os1::process::init","The init process routine",null,{"inputs":[{"name":"process"}],"output":{"name":"usize"}}],[0,"idle","os1::process","A module for the idle process, a process that runs when there is\nnothing else left to do.",null,null],[5,"init","os1::process::idle","Create the idle process but do not start it until we need it",null,{"inputs":[],"output":null}],[5,"run","","Just waste a quantum and hopefully there will be something to do",null,{"inputs":[{"name":"process"}],"output":{"name":"usize"}}],[7,"IDLE_PROCESS","","The idle process",null,null],[0,"reaper","os1::process","A module for the reaper process, a process which frees the resources\nof dead processes.",null,null],[5,"run","os1::process::reaper","The reaper process routine:\nIf there are dead processes, pop them from the\nREAPER_QUEUE and free their resources.",null,{"inputs":[{"name":"process"}],"output":{"name":"usize"}}],[5,"reaper_add","","Add a dead process to the reaper queue.\nNOTE: This should only be done for processes that will never run again",null,null],[5,"init","","Create the reaper process and add it to the ready queue",null,{"inputs":[],"output":null}],[7,"REAPER_SEMAPHORE","","The reaper blocks onto this semaphore until enough have died",null,null],[7,"REAPER_QUEUE","","The reaper queue. A queue of dead processes",null,null],[0,"user","os1::process","A module for user processes",null,null],[5,"run","os1::process::user","",null,{"inputs":[{"name":"process"}],"output":{"name":"usize"}}],[5,"get_prev","","",null,null],[5,"get_next","","",null,null],[5,"run2","","",null,{"inputs":[{"name":"process"}],"output":{"name":"usize"}}],[5,"run3","","",null,{"inputs":[{"name":"process"}],"output":{"name":"usize"}}],[7,"current","","",null,null],[7,"s1","","",null,null],[7,"s2","","",null,null],[17,"ROWS","","",null,null],[17,"COLS","","",null,null],[17,"NUM_LOOP","","",null,null],[6,"ProcessQueue","os1::process","Type alias for a queue of Processes",null,null],[7,"NEXT_ID","","The next available PID",null,null],[7,"CURRENT_PROCESS","","The current running process if there is one",null,null],[17,"STACK_SIZE","","Size of a kernel stack (number of words)",null,null],[11,"eq","","",35,{"inputs":[{"name":"state"},{"name":"state"}],"output":{"name":"bool"}}],[11,"ne","","",35,{"inputs":[{"name":"state"},{"name":"state"}],"output":{"name":"bool"}}],[11,"clone","","",35,{"inputs":[{"name":"state"}],"output":{"name":"state"}}],[11,"new","","Create a new process with the given name and routine. Because processes\nare a fundamental abstraction, they are too low level for me to use Rust well.\nFor this reason, a raw pointer is returned to the process, and it is the\njob of the caller to arrange for the process to be reaped.",34,null],[11,"get_stack","","A helper to get a kernel stack for this process",34,{"inputs":[{"name":"process"}],"output":null}],[11,"set_state","","Set the state of the process to `s`",34,{"inputs":[{"name":"process"},{"name":"state"}],"output":null}],[11,"get_state","","",34,{"inputs":[{"name":"process"}],"output":{"name":"state"}}],[11,"get_pid","","",34,{"inputs":[{"name":"process"}],"output":{"name":"usize"}}],[11,"drop","","When the process is reaped, we must free its stack",34,{"inputs":[{"name":"process"}],"output":null}],[11,"fmt","","Allow processes to be printed elegantly in format strings",34,{"inputs":[{"name":"process"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","Two processes are the same if they have the same PID",34,{"inputs":[{"name":"process"},{"name":"process"}],"output":{"name":"bool"}}],[0,"vga","os1","This module contains a primitive display driver for the kernel\nwhile in VGA mode.",null,null],[0,"vga","os1::vga","A module for VGA buffer manipulation",null,null],[3,"VGAChar","os1::vga::vga","Represents a single character in the VGA buffer.\nThe first byte represents the ASCII character. The next\n4 bits represent the background color. The last 4 bits\nrepresent the forground color.",null,null],[12,"ch","","",39,null],[12,"color","","",39,null],[3,"VGABuff","","Abstracts the VGA buffer",null,null],[12,"buff","","",40,null],[3,"VGA","","Safe wrapper around unsafe VGA buffer.\nProvides the abstraction of a cursor and \"screen\"",null,null],[12,"fg","","",41,null],[12,"bg","","",41,null],[12,"cursor","","",41,null],[4,"Color","","Colors for VGA display",null,null],[13,"Black","","",42,null],[13,"Blue","","",42,null],[13,"Green","","",42,null],[13,"Cyan","","",42,null],[13,"Red","","",42,null],[13,"Pink","","",42,null],[13,"Brown","","",42,null],[13,"LightGray","","",42,null],[13,"DarkGray","","",42,null],[13,"LightBlue","","",42,null],[13,"LightGreen","","",42,null],[13,"LightCyan","","",42,null],[13,"LightRed","","",42,null],[13,"LightPink","","",42,null],[13,"Yellow","","",42,null],[13,"White","","",42,null],[7,"VGA_BUFFER","","The VGA buffer",null,null],[17,"ROWS","","Number of rows in the VGA buffer",null,null],[17,"COLS","","Number of columns in the VGA buffer",null,null],[17,"VGA_CMD","","The VGA command port",null,null],[17,"VGA_DATA","","The VGA data port",null,null],[11,"clone","","",42,{"inputs":[{"name":"color"}],"output":{"name":"color"}}],[11,"clone","","",39,{"inputs":[{"name":"vgachar"}],"output":{"name":"vgachar"}}],[11,"clone","","",40,{"inputs":[{"name":"vgabuff"}],"output":{"name":"vgabuff"}}],[11,"clone","","",41,{"inputs":[{"name":"vga"}],"output":{"name":"vga"}}],[11,"set_fg","","Set the forground color of the character",39,{"inputs":[{"name":"vgachar"},{"name":"color"}],"output":null}],[11,"set_bg","","Set the background color of the character",39,{"inputs":[{"name":"vgachar"},{"name":"color"}],"output":null}],[11,"set_char","","Set the ASCII character",39,{"inputs":[{"name":"vgachar"},{"name":"char"}],"output":null}],[11,"index","","",40,null],[11,"index_mut","","",40,null],[11,"new","","Create a new VGA handle",41,{"inputs":[{"name":"vga"}],"output":{"name":"vga"}}],[11,"fill_rect","","Clear the rectangle and paint it with the background color",41,null],[11,"clear_screen","","Paint the whole screen black",41,{"inputs":[{"name":"vga"}],"output":null}],[11,"put_char","","Set character at the cursor",41,{"inputs":[{"name":"vga"},{"name":"char"}],"output":null}],[11,"set_fg","","Set foreground color of the cursor",41,{"inputs":[{"name":"vga"},{"name":"color"}],"output":null}],[11,"set_bg","","Set background color of the cursor",41,{"inputs":[{"name":"vga"},{"name":"color"}],"output":null}],[11,"set_cursor","","Set position of the cursor",41,null],[0,"window","os1::vga","A module for primitive window drawing",null,null],[3,"Window","os1::vga::window","The abstration of a window.",null,null],[12,"height","","",43,null],[12,"width","","",43,null],[12,"pos","","",43,null],[12,"cursor","","",43,null],[12,"vga","","",43,null],[4,"Color","","Colors for VGA display",null,null],[13,"Black","","",42,null],[13,"Blue","","",42,null],[13,"Green","","",42,null],[13,"Cyan","","",42,null],[13,"Red","","",42,null],[13,"Pink","","",42,null],[13,"Brown","","",42,null],[13,"LightGray","","",42,null],[13,"DarkGray","","",42,null],[13,"LightBlue","","",42,null],[13,"LightGreen","","",42,null],[13,"LightCyan","","",42,null],[13,"LightRed","","",42,null],[13,"LightPink","","",42,null],[13,"Yellow","","",42,null],[13,"White","","",42,null],[11,"clone","","",43,{"inputs":[{"name":"window"}],"output":{"name":"window"}}],[11,"new","","Create a new Window.",43,null],[11,"clear_screen","","A static method to clear the screen.",43,{"inputs":[{"name":"window"}],"output":null}],[11,"paint","","Paint the window with the background color",43,{"inputs":[{"name":"window"}],"output":null}],[11,"put_char","","Draw the character at the cursor relative to the corner of window\nif the character is inside the window.",43,{"inputs":[{"name":"window"},{"name":"char"}],"output":null}],[11,"put_str","","Render the string at the cursor using word wrapping.",43,{"inputs":[{"name":"window"},{"name":"str"}],"output":null}],[11,"set_fg","","Set the foreground color",43,{"inputs":[{"name":"window"},{"name":"color"}],"output":null}],[11,"set_bg","","Set the background color",43,{"inputs":[{"name":"window"},{"name":"color"}],"output":null}],[11,"set_cursor","","Set the cursor position",43,null],[14,"printf!","os1","A macro for printing using format strings to the console\nwhen interrupts are enabled",null,null],[14,"bootlog!","","A macro for printing using format strings to the console\nwhen interrupts are not enabled",null,null]],"paths":[[3,"Debug"],[3,"Vec"],[3,"LinkedList"],[3,"Rawlink"],[3,"Node"],[3,"Iter"],[3,"IterMut"],[3,"IntoIter"],[3,"StaticLinkedList"],[3,"Rawlink"],[3,"Node"],[3,"Iter"],[3,"IterMut"],[3,"IntoIter"],[3,"Semaphore"],[3,"StaticSemaphore"],[3,"SemaphoreGuard"],[3,"Barrier"],[3,"Event"],[3,"TableDescriptor"],[3,"IDTDescr"],[3,"AddressSpace"],[3,"Block"],[3,"TSSDescriptor"],[3,"TSS"],[3,"Frame"],[3,"FrameInfoSection"],[3,"FrameInfo"],[3,"SharedFrameInfo"],[3,"PagingEntry"],[3,"VMTable"],[3,"MemoryListEntry"],[3,"Region"],[3,"RegionMap"],[3,"Process"],[4,"State"],[3,"KContext"],[3,"ProcessTable"],[3,"ProcessTableNode"],[3,"VGAChar"],[3,"VGABuff"],[3,"VGA"],[4,"Color"],[3,"Window"]]};
initSearch(searchIndex);
