var searchIndex = {};
searchIndex['rustcode'] = {"items":[[0,"","rustcode","The os1 kernel is written and compiled as a library. It is then\ncompiled and linked together with assembly files to produce a binary.\nThe binary is written to the hard disk, which is then loaded.",null,null],[5,"store_kcontext","","Save the `KContext` of the current process to its process struct",null,null],[5,"_proc_yield","","The unsafe function that does the actual work of choosing the\nnext process and switching to it.",null,{"inputs":[{"name":"option"}],"output":null}],[5,"pic_irq","","Rust-side IRQ handling code",null,{"inputs":[{"name":"usize"}],"output":null}],[5,"vmm_page_fault","","The Rust-side code of the page fault handler.",null,{"inputs":[{"name":"usize"}],"output":null}],[5,"kernel_main","","This is the entry point to the kernel. It is the first rust code that runs.",null,{"inputs":[],"output":null}],[0,"debug","","This module allows the user to print to QEMU's serial console.",null,null],[3,"Debug","rustcode::debug","A struct to write data to the console port",null,null],[17,"PORT","","Port to output to serial console",null,null],[11,"write_bytes","","Wait for the port, then write the given array of bytes",0,null],[11,"write_str","","Take a string slice and write to the serial console",0,{"inputs":[{"name":"debug"},{"name":"str"}],"output":{"name":"result"}}],[0,"bare_bones","rustcode","This module contains some basic functionality that libstd would normally\notherwise provide. Most importantly, it defines `rust_begin_unwind` which is\nused by `panic!`.",null,null],[5,"stack_exhausted","rustcode::bare_bones","",null,{"inputs":[],"output":null}],[5,"eh_personality","","",null,{"inputs":[],"output":null}],[5,"rust_begin_unwind","","This function is used by `panic!` to display an error message.",null,{"inputs":[{"name":"arguments"},{"name":"str"},{"name":"u32"}],"output":null}],[0,"data_structures","rustcode","A module containing useful data structures",null,null],[3,"ProcessQueue","rustcode::data_structures","An abstraction for any kind of process queue",null,null],[12,"head","","",1,null],[12,"tail","","",1,null],[0,"proc_queue","","",null,null],[3,"ProcessQueue","rustcode::data_structures::proc_queue","An abstraction for any kind of process queue",null,null],[12,"head","","",1,null],[12,"tail","","",1,null],[11,"new","rustcode::data_structures","Create a new, empty queue. This is a const function, so statics can have\nqueues.",1,{"inputs":[{"name":"processqueue"}],"output":{"name":"processqueue"}}],[11,"push_tail","","Push the given process to the end of the queue. O(1)",1,null],[11,"pop_head","","Pop and return the head of the queue. If this method returns a null\npointer, then the queue is empty. O(1)",1,null],[0,"concurrency","","A module for concurrency primitives",null,null],[3,"Semaphore","rustcode::data_structures::concurrency","`Semaphore` is a much more Rustic semaphore. It returns an RAII\n`SemaphoreGuard`, which automatically calls \"up\" when it goes out of\nscope. This semaphore takes ownership of the data it is guarding, so that\nRust ownership and lifetime semantics can be used to guarantee safety of\nthe resource.",null,null],[12,"inner","","",2,null],[12,"data","","",2,null],[3,"StaticSemaphore","","`StaticSemaphore` is a semaphore implementation that can be used in\nstatics. It has a const constructor.",null,null],[12,"count","","",3,null],[12,"queue","","",3,null],[3,"SemaphoreGuard","","RAII SemaphoreGuard",null,null],[12,"semaphore","","",4,null],[12,"data","","",4,null],[0,"semaphore","","A semaphore implementation based on the rust Mutex<T> type",null,null],[3,"Semaphore","rustcode::data_structures::concurrency::semaphore","`Semaphore` is a much more Rustic semaphore. It returns an RAII\n`SemaphoreGuard`, which automatically calls \"up\" when it goes out of\nscope. This semaphore takes ownership of the data it is guarding, so that\nRust ownership and lifetime semantics can be used to guarantee safety of\nthe resource.",null,null],[12,"inner","","",2,null],[12,"data","","",2,null],[3,"StaticSemaphore","","`StaticSemaphore` is a semaphore implementation that can be used in\nstatics. It has a const constructor.",null,null],[12,"count","","",3,null],[12,"queue","","",3,null],[3,"SemaphoreGuard","","RAII SemaphoreGuard",null,null],[12,"semaphore","","",4,null],[12,"data","","",4,null],[11,"new","rustcode::data_structures::concurrency","Create a new semaphore with the the given count guarding the given value",2,{"inputs":[{"name":"semaphore"},{"name":"t"},{"name":"isize"}],"output":{"name":"semaphore"}}],[11,"down","","Acquire.\nreturns an RAII guard, so no need for up()",2,{"inputs":[{"name":"semaphore"}],"output":{"name":"semaphoreguard"}}],[11,"drop","","When the semaphore goes out of scope, it destroys the contents",2,{"inputs":[{"name":"semaphore"}],"output":null}],[11,"new","","Create a new `StaticSemaphore` with the given count",3,{"inputs":[{"name":"staticsemaphore"},{"name":"isize"}],"output":{"name":"staticsemaphore"}}],[11,"down","","Acquire",3,{"inputs":[{"name":"staticsemaphore"}],"output":null}],[11,"up","","Release",3,{"inputs":[{"name":"staticsemaphore"}],"output":null}],[11,"destroy","","Clean up.\nCannot implement Drop here because we want to be able\nto create a static semaphore.",3,{"inputs":[{"name":"staticsemaphore"}],"output":null}],[11,"new","","Create a guard referring to the given semaphore and data",4,{"inputs":[{"name":"semaphoreguard"},{"name":"staticsemaphore"},{"name":"unsafecell"}],"output":{"name":"semaphoreguard"}}],[11,"drop","","`SemaphoreGuard` is RAII, so dropping the guard calls up",4,{"inputs":[{"name":"semaphoreguard"}],"output":null}],[11,"deref","","",4,{"inputs":[{"name":"semaphoreguard"}],"output":{"name":"t"}}],[11,"deref_mut","","",4,{"inputs":[{"name":"semaphoreguard"}],"output":{"name":"t"}}],[0,"machine","rustcode","This is the Rust-side handle for assembly code. Most of the FFI handles are\nin this module.",null,null],[5,"inb","rustcode::machine","a wrapper around inb",null,null],[5,"inl","","a wrapper around inl",null,null],[5,"outb","","a wrapper around outb",null,null],[5,"ltr","","a wrapper around ltr",null,null],[5,"pit_do_init","","Initialize the PIT with the given divide",null,null],[5,"vmm_on","","Turn on VM and load cr3 with the given value",null,null],[5,"invlpg","","Flush the page from the TLB",null,null],[5,"cli","","a wrapper around cli",null,null],[5,"sti","","a wrapper around sti",null,null],[5,"irq0","","A handler for IRQ 0",null,null],[5,"irq1","","A handler for IRQ 1",null,null],[5,"irq2","","A handler for IRQ 2",null,null],[5,"irq3","","A handler for IRQ 3",null,null],[5,"irq4","","A handler for IRQ 4",null,null],[5,"irq5","","A handler for IRQ 5",null,null],[5,"irq6","","A handler for IRQ 6",null,null],[5,"irq7","","A handler for IRQ 7",null,null],[5,"irq8","","A handler for IRQ 8",null,null],[5,"irq9","","A handler for IRQ 9",null,null],[5,"irq10","","A handler for IRQ 10",null,null],[5,"irq11","","A handler for IRQ 11",null,null],[5,"irq12","","A handler for IRQ 12",null,null],[5,"irq13","","A handler for IRQ 13",null,null],[5,"irq14","","A handler for IRQ 14",null,null],[5,"irq15","","A handler for IRQ 15",null,null],[5,"proc_yield","","An unsafe proc_yield handle that saves the context of the current\nprocess before switching. *Do not* call this function directly! Instead,\nuse `process::proc_yield`, which is a wrapper around this function.",null,null],[5,"context_switch","","Do a context switch to `next_context` with the eflags register set to\n`eflags`. This function is called by `process::proc_yield`",null,null],[5,"eflags","","Returns the value of eflags",null,null],[5,"page_fault_handler","","The assembly handle for the page fault handler. This function calls\n`vmm_page_fault`.",null,null],[0,"memory","rustcode","This module contains everything that has to do with memory",null,null],[3,"AddressSpace","rustcode::memory","The address space of a single process",null,null],[12,"page_dir","","",5,null],[12,"kmap_index","","",5,null],[5,"vmm_page_fault","","The Rust-side code of the page fault handler.",null,{"inputs":[{"name":"usize"}],"output":null}],[5,"esp0","","",null,{"inputs":[{"name":"usize"}],"output":null}],[5,"init","","Initialize all memory subsystems",null,{"inputs":[],"output":null}],[0,"rust_alloc","","This module contains the outside interface with the kernels memory allocator.\nrustc will look for these functions.",null,null],[5,"__rust_allocate","rustcode::memory::rust_alloc","Return a pointer to `size` bytes of memory aligned to `align`.",null,null],[5,"__rust_deallocate","","Deallocates the memory referenced by `ptr`.",null,null],[5,"__rust_reallocate","","Resize the allocation referenced by `ptr` to `size` bytes.",null,null],[5,"__rust_reallocate_inplace","","Resize the allocation referenced by `ptr` to `size` bytes.",null,null],[5,"__rust_usable_size","","Returns the usable size of an allocation created with the specified the\n`size` and `align`.",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"usize"}}],[5,"__rust_stats_print","","Prints implementation-defined allocator statistics.",null,{"inputs":[],"output":null}],[0,"heap","rustcode::memory","This file contains the memory allocator used by the rust_alloc module",null,null],[3,"Block","rustcode::memory::heap","A struct representing a heap block.",null,null],[5,"round_to_block_align","","Round up to the nearest multiple of `BLOCK_ALIGN`",null,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[5,"round_to_n","","Round the size to `n`. `n` must be a power of 2",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"usize"}}],[5,"init","","Initialize the kernel heap",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":null}],[5,"malloc","","Return a pointer to `size` bytes of memory aligned to `align`.",null,null],[5,"free","","Deallocates the memory referenced by `ptr`.",null,null],[5,"usable_size","","Returns the usable size of an allocation created with the specified the\n`size` and `align`.",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"usize"}}],[5,"print_stats","","Prints implementation-defined allocator statistics.",null,{"inputs":[],"output":null}],[5,"get_block_stats","","Helper method to compute stats",null,null],[7,"BLOCK_ALIGN","","A const representing the minimum alignment of any block.\nIt is effectively a const, but it has to be initialized at startup because `size_of` is\nnon-const.",null,null],[7,"START","","The start address of the kernel heap",null,null],[7,"END","","The end address of the kernel heap. That is, the first address that is not in the heap.",null,null],[7,"free_list","","A pointer to the first free heap block",null,null],[7,"SUCC_MALLOCS","","The number of successful mallocs (for stats purposes)",null,null],[7,"FAIL_MALLOCS","","The number of unsuccessful mallocs (for stats purposes)",null,null],[7,"FREES","","The number of successful frees (for stats purposes)",null,null],[17,"DEBUG","","A flag to turn on and off debugging output",null,null],[11,"get_head","","Returns the first word of the block, which will contain the size if this is a free block",6,{"inputs":[{"name":"block"}],"output":{"name":"usize"}}],[11,"set_head","","Sets the header to the given value",6,{"inputs":[{"name":"block"},{"name":"usize"}],"output":null}],[11,"get_foot","","Returns the last word of the block, which will contain the size if this is a free block",6,{"inputs":[{"name":"block"}],"output":{"name":"usize"}}],[11,"set_foot","","Sets the footer to the given value",6,{"inputs":[{"name":"block"},{"name":"usize"}],"output":null}],[11,"get_free_bits","","Gets the 4 free bits of the block",6,{"inputs":[{"name":"block"}],"output":{"name":"u8"}}],[11,"set_next","","Set the forward pointer (but not the free bits)",6,null],[11,"set_prev","","Set the backward pointer",6,null],[11,"is_free","","Returns true if the block is a valid free block.\nThis method does a lot of sanity checiking",6,{"inputs":[{"name":"block"}],"output":{"name":"bool"}}],[11,"mark_free","","Set the free bits",6,{"inputs":[{"name":"block"}],"output":null}],[11,"mark_used","","Clear the free bits.\nThe block should already be removed from the free list",6,{"inputs":[{"name":"block"}],"output":null}],[11,"get_size","","Return the size of the block (user-usable data size)",6,{"inputs":[{"name":"block"}],"output":{"name":"usize"}}],[11,"set_size","","Set the size of block",6,{"inputs":[{"name":"block"},{"name":"usize"}],"output":null}],[11,"get_contiguous_next","","Returns the heap block immediately following this one",6,null],[11,"get_contiguous_prev","","Returns the heap block immediately preceding this one\nor null if there is no valid previous block.",6,null],[11,"get_free_next","","Returns the forward ptr of the block (excluding the free bits)",6,null],[11,"get_free_prev","","Returns the backward ptr of the block",6,null],[11,"remove","","Remove from free list. Clear forward/backward pointers",6,{"inputs":[{"name":"block"}],"output":null}],[11,"insert","","Add to head of free list",6,{"inputs":[{"name":"block"}],"output":null}],[11,"merge_with_next","","Merge this block with the next block.\nRemoves the second block from the free list before merging",6,{"inputs":[{"name":"block"}],"output":null}],[11,"split","","Split the block so that it is the given size.\nInsert the new block into the free list.\nThe block must be large enough to split (`>= 2*BLOCK_ALIGN`).\nThe block must be free.\nThe new size must be a multiple of `BLOCK_ALIGN`.",6,{"inputs":[{"name":"block"},{"name":"usize"}],"output":null}],[11,"is_match","","Returns true if this block matches the size and alignment.\nReturns the size at which the block should be split to obtain\nan aligned block; the second return value is meaningless if\nwe return false.",6,null],[0,"tss","rustcode::memory","",null,null],[3,"TSSDescriptor","rustcode::memory::tss","",null,null],[12,"f0","","",7,null],[12,"f1","","",7,null],[3,"TSS","","",null,null],[12,"prev","","",8,null],[12,"esp0","","",8,null],[12,"ss0","","",8,null],[12,"esp1","","",8,null],[12,"ss1","","",8,null],[12,"esp2","","",8,null],[12,"ss2","","",8,null],[12,"unused","","",8,null],[5,"init","","",null,{"inputs":[],"output":null}],[5,"esp0","","",null,{"inputs":[{"name":"usize"}],"output":null}],[7,"tssDescriptor","","",null,null],[7,"tssDS","","",null,null],[7,"kernelDataSeg","","",null,null],[7,"TSS_","","",null,null],[11,"set","","",7,{"inputs":[{"name":"tssdescriptor"},{"name":"tss"},{"name":"usize"}],"output":null}],[11,"new","","",8,{"inputs":[{"name":"tss"}],"output":{"name":"tss"}}],[11,"esp0","","",8,{"inputs":[{"name":"tss"},{"name":"usize"}],"output":null}],[0,"physmem","rustcode::memory","Physical memory management",null,null],[3,"Frame","rustcode::memory::physmem","A physical memory frame",null,null],[12,"mem","","",9,null],[3,"FrameInfoSection","","Should take up 4MiB on a 32-bit machine.\nThere is one frame info for each frame, associated by frame index",null,null],[12,"arr","","",10,null],[3,"FrameInfo","","Frame info\n```\nWhen free\n31                 20           0\n[nnnnnnnnnnnnnnnnnnnn           1]\n ^-- next free index            ^-- free bit",null,null],[12,"info","","",11,null],[5,"init","","Initialize physical memory frames using the rest of physical memory.\nThis function detects all available physical memory.",null,{"inputs":[{"name":"usize"}],"output":null}],[7,"FRAME_INFO","","Array of `FrameInfo`. This is a pointer to the region of memory used\nto hold physical memory allocation metadata.",null,null],[7,"FREE_FRAMES","","The index of the first free frame in a LIFO list.\n0 => empty list",null,null],[11,"alloc","","Allocate a frame and return its physical address",9,{"inputs":[{"name":"frame"}],"output":{"name":"usize"}}],[11,"free","","Free the frame with the given index",9,{"inputs":[{"name":"frame"},{"name":"usize"}],"output":null}],[11,"index","","",9,{"inputs":[{"name":"frame"},{"name":"usize"}],"output":{"name":"usize"}}],[11,"index_mut","","",9,{"inputs":[{"name":"frame"},{"name":"usize"}],"output":{"name":"usize"}}],[11,"index","","",10,{"inputs":[{"name":"frameinfosection"},{"name":"usize"}],"output":{"name":"frameinfo"}}],[11,"index_mut","","",10,{"inputs":[{"name":"frameinfosection"},{"name":"usize"}],"output":{"name":"frameinfo"}}],[11,"alloc","","Allocate the frame referred to by this `FrameInfo`.\nNOTE: this should only be called on the first frame in the free list",11,{"inputs":[{"name":"frameinfo"}],"output":null}],[11,"free","","Free the frame referred to by this FrameInfo",11,{"inputs":[{"name":"frameinfo"}],"output":null}],[11,"get_index","","Get the index of the `Frame`",11,{"inputs":[{"name":"frameinfo"}],"output":{"name":"usize"}}],[11,"set_free","","Set the free bit of this `FrameInfo` to 1 if `free` is true; else 0",11,{"inputs":[{"name":"frameinfo"},{"name":"bool"}],"output":null}],[11,"get_next_free","","Get the index of the next free frame",11,{"inputs":[{"name":"frameinfo"}],"output":{"name":"usize"}}],[11,"set_next_free","","Set the index of the next free frame",11,{"inputs":[{"name":"frameinfo"},{"name":"usize"}],"output":null}],[0,"virtmem","rustcode::memory","A module for virtual memory management",null,null],[3,"AddressSpace","rustcode::memory::virtmem","The address space of a single process",null,null],[12,"page_dir","","",5,null],[12,"kmap_index","","",5,null],[3,"PagingEntry","","A single entry in a page directory or table\n```\n31                 12  9       0\n[                    000 flags  ]\n```",null,null],[12,"entry","","",12,null],[3,"VMTable","","An abstraction of page directories and page tables",null,null],[12,"entries","","",13,null],[5,"init","","Initialize virtual memory management but do not turn on VM.\nThis creates the two shared page tables that map the first 8MiB.",null,{"inputs":[],"output":null}],[5,"vmm_page_fault","","The Rust-side code of the page fault handler.",null,{"inputs":[{"name":"usize"}],"output":null}],[7,"PDE0","","Shared PDE #0: direct mapping the first 4MiB",null,null],[7,"PDE1","","Shared PDE #1: direct mapping the second 4MiB",null,null],[7,"VMM_ON","","Is VM on?",null,null],[11,"clone","","",12,{"inputs":[{"name":"pagingentry"}],"output":{"name":"pagingentry"}}],[11,"new","rustcode::memory","Create a new address space. Each address space has the first\n8MiB direct mapped. The next 4MiB is mapped to the page directory",5,{"inputs":[{"name":"addressspace"}],"output":{"name":"addressspace"}}],[11,"map","","Map `virt` to `phys` in the address space.\nNOTE: should only be called on the current address space\nbecause it assumes that the PD is at 0x802000",5,{"inputs":[{"name":"addressspace"},{"name":"usize"},{"name":"usize"}],"output":null}],[11,"kmap","","Map the given `paddr` for temporary use by the kernel and return a mut reference to the\nframe.\nNOTE: should only be called on the current address space because it assumes that the PD is\nat 0x802000",5,{"inputs":[{"name":"addressspace"},{"name":"usize"}],"output":{"name":"frame"}}],[11,"unmap","","Remove any mapping for this virtual address\nNOTE: should only be called on the current address space because it assumes that the PD is\nat 0x802000",5,{"inputs":[{"name":"addressspace"},{"name":"usize"}],"output":null}],[11,"activate","","Activate the current address space and turn on VM if needed",5,{"inputs":[{"name":"addressspace"}],"output":null}],[11,"clear","","Remove all non-kernel mappings in this address space.\nNOTE: must run while this address space is active",5,{"inputs":[{"name":"addressspace"}],"output":null}],[11,"drop","","Deallocate the page directory.\nNOTE: cannot run while the address space is active",5,{"inputs":[{"name":"addressspace"}],"output":null}],[11,"new","rustcode::memory::virtmem","Get a blank entry",12,{"inputs":[{"name":"pagingentry"}],"output":{"name":"pagingentry"}}],[11,"set_present","","Set the present bit.\ntrue = present; false = not present",12,{"inputs":[{"name":"pagingentry"},{"name":"bool"}],"output":null}],[11,"set_read_write","","Set the read/write bit.\ntrue = read/write, false = read-only",12,{"inputs":[{"name":"pagingentry"},{"name":"bool"}],"output":null}],[11,"set_privelege_level","","Set the privelege level bit.\ntrue = all, false = kernel mode only",12,{"inputs":[{"name":"pagingentry"},{"name":"bool"}],"output":null}],[11,"set_caching","","Set caching bit.\ntrue = write-through, false = write-back",12,{"inputs":[{"name":"pagingentry"},{"name":"bool"}],"output":null}],[11,"set_flag","","Set the `index`-th flag to `value`.\ntrue = 1; false = 0",12,{"inputs":[{"name":"pagingentry"},{"name":"u8"},{"name":"bool"}],"output":null}],[11,"set_address","","Set the upper 20 bits of the entry to the upper 20 bits of `address`",12,{"inputs":[{"name":"pagingentry"},{"name":"usize"}],"output":null}],[11,"is_flag","","Return true if the `index`-th bit is set",12,{"inputs":[{"name":"pagingentry"},{"name":"u8"}],"output":{"name":"bool"}}],[11,"get_address","","Return the upper 20-bits of the entry",12,{"inputs":[{"name":"pagingentry"}],"output":{"name":"usize"}}],[11,"free","","Free the frame pointed to if `dealloc` and mark this entry not present.",12,{"inputs":[{"name":"pagingentry"},{"name":"bool"}],"output":null}],[11,"new","","Returns a reference to a new `VMTable` and its physical address.\nThe new table is kmapped if necessary, and is always cleared.",13,null],[11,"index","","",13,{"inputs":[{"name":"vmtable"},{"name":"usize"}],"output":{"name":"pagingentry"}}],[11,"index_mut","","",13,{"inputs":[{"name":"vmtable"},{"name":"usize"}],"output":{"name":"pagingentry"}}],[0,"regionmap","rustcode::memory","Module for detecting available physical memory",null,null],[3,"MemoryListEntry","rustcode::memory::regionmap","Represents an entry in the list of memory regions generated by the E820\nBIOS call.",null,null],[12,"base_l","","",14,null],[12,"base_h","","",14,null],[12,"length_l","","",14,null],[12,"length_h","","",14,null],[12,"region_type","","",14,null],[12,"acpi","","",14,null],[3,"Region","","Represents a region of memory",null,null],[12,"start","","",15,null],[12,"end","","",15,null],[12,"usable","","",15,null],[12,"next","","",15,null],[3,"RegionMap","","Represents a map of memory regions",null,null],[12,"list","","",16,null],[12,"index","","",16,null],[7,"memory_map_count","","",null,null],[7,"memory_map","","",null,null],[11,"new","","Recursively create regions and return a chain\nthat stretches from `start` to the end of the 32-bit addr space.\nEach iteration is O(n), but it doesn't matter much because n < 2*20",15,{"inputs":[{"name":"region"},{"name":"usize"}],"output":{"name":"region"}}],[11,"find","","Find the length and type of the most restrictive\nmapping for `addr` based on the E820 BIOS call",15,{"inputs":[{"name":"region"},{"name":"usize"}],"output":{"name":"option"}}],[11,"find_next","","Find the beginning address of the next region of memory\nbased on the E820 BIOS call",15,{"inputs":[{"name":"region"},{"name":"usize"}],"output":{"name":"usize"}}],[11,"dump","","Recursively print mappings. Used for debugging",15,{"inputs":[{"name":"region"}],"output":null}],[11,"new","","Produce a map of all memory after start.\nThis is a 32-bit OS, so we only have to deal with 4GB",16,null],[11,"next","","",16,{"inputs":[{"name":"regionmap"}],"output":{"name":"option"}}],[0,"process","rustcode","A module for process management",null,null],[3,"Process","rustcode::process","Represents a single process, its identity, resources, etc.",null,null],[12,"name","","Name of the process; not necessarily unique",17,null],[12,"pid","","Unique 32-bit identifier",17,null],[12,"run","","The routine of the process",17,null],[12,"state","","The current state of the process",17,null],[12,"stack","","A pointer to the kheap-allocated stack space for this process's\nkernel stack. This pointer is to the bottom of the stack, not the head.",17,null],[12,"kcontext","","The saved kernel context for context switching",17,null],[12,"addr_space","","The virtual memory address space of the process",17,null],[12,"disable_cnt","","Number of calls to interrupts::on() while this process was running\nInterrupts are on if `disable_cnt == 0`",17,null],[12,"next_proc","","A link for use in process queues",17,null],[4,"State","","An enum representing the possible states of a process",null,null],[13,"INIT","","Process is created, but not ready",18,null],[13,"READY","","Process is in the ready q",18,null],[13,"RUNNING","","Process is running (not on the ready q or blocked)",18,null],[13,"BLOCKED","","Process is blocked on a q",18,null],[13,"TERMINATED","","Process has died",18,null],[5,"init","","Initialize the process subsystem.\nThis creates the init, idle, and reaper processes, but does not\nstart any of them yet.",null,{"inputs":[],"output":null}],[5,"start_proc","","The entry point of all processes",null,{"inputs":[],"output":null}],[5,"proc_yield","","A safe wrapper around machine::proc_yield.",null,{"inputs":[{"name":"option"}],"output":null}],[5,"_proc_yield","","The unsafe function that does the actual work of choosing the\nnext process and switching to it.",null,{"inputs":[{"name":"option"}],"output":null}],[5,"exit","","Called by the current process to exit with the given exit code",null,{"inputs":[{"name":"usize"}],"output":null}],[0,"context","","A module for saving a process's context",null,null],[3,"KContext","rustcode::process::context","A struct representing the contents of the general purpose registers\nas produced by the `pusha` instruction.",null,null],[12,"edi","","",19,null],[12,"esi","","",19,null],[12,"ebp","","",19,null],[12,"esp","","",19,null],[12,"ebx","","",19,null],[12,"edx","","",19,null],[12,"ecx","","",19,null],[12,"eax","","",19,null],[5,"store_kcontext","","Save the `KContext` of the current process to its process struct",null,null],[11,"clone","","",19,{"inputs":[{"name":"kcontext"}],"output":{"name":"kcontext"}}],[11,"new","","Create a new empty context struct",19,{"inputs":[{"name":"kcontext"}],"output":{"name":"kcontext"}}],[0,"ready_queue","rustcode::process","A module for the ready queue",null,null],[5,"make_ready","rustcode::process::ready_queue","Add the process to the ready queue",null,null],[5,"get_next","","Unqueue and return the next ready process.\nNOTE: returns null if there are no ready processes",null,null],[7,"READY_QUEUE","","The ready queue. A queue containing all processes that are ready to be scheduled.",null,null],[0,"init","rustcode::process","A module for the init process",null,null],[5,"run","rustcode::process::init","The init process routine",null,{"inputs":[{"name":"process"}],"output":{"name":"usize"}}],[0,"idle","rustcode::process","A module for the idle process, a process that runs when there is\nnothing else left to do.",null,null],[5,"init","rustcode::process::idle","Create the idle process but do not start it until we need it",null,{"inputs":[],"output":null}],[5,"run","","Just waste a quantum and hopefully there will be something to do",null,{"inputs":[{"name":"process"}],"output":{"name":"usize"}}],[7,"IDLE_PROCESS","","The idle process",null,null],[0,"reaper","rustcode::process","A module for the reaper process, a process which frees the resources\nof dead processes.",null,null],[5,"run","rustcode::process::reaper","The reaper process routine:\nIf there are dead processes, pop them from the\nREAPER_QUEUE and free their resources.",null,{"inputs":[{"name":"process"}],"output":{"name":"usize"}}],[5,"reaper_add","","Add a dead process to the reaper queue.\nNOTE: This should only be done for processes that will never run again",null,null],[5,"init","","Create the reaper process and add it to the ready queue",null,{"inputs":[],"output":null}],[7,"REAPER_SEMAPHORE","","The reaper blocks onto this semaphore until enough have died",null,null],[7,"REAPER_QUEUE","","The reaper queue. A queue of dead processes",null,null],[0,"user","rustcode::process","A module for user processes",null,null],[5,"run","rustcode::process::user","",null,{"inputs":[{"name":"process"}],"output":{"name":"usize"}}],[5,"get_prev","","",null,null],[5,"get_next","","",null,null],[5,"run2","","",null,{"inputs":[{"name":"process"}],"output":{"name":"usize"}}],[7,"current","","",null,null],[7,"s1","","",null,null],[7,"s2","","",null,null],[17,"ROWS","","",null,null],[17,"COLS","","",null,null],[7,"NEXT_ID","rustcode::process","The next available PID",null,null],[7,"CURRENT_PROCESS","","The current running process if there is one",null,null],[17,"STACK_SIZE","","Size of a kernel stack (number of words)",null,null],[11,"clone","","",18,{"inputs":[{"name":"state"}],"output":{"name":"state"}}],[11,"new","","Create a new process with the given name and routine. Because processes\nare a fundamental abstraction, they are too low level for me to use Rust well.\nFor this reason, a raw pointer is returned to the process, and it is the\njob of the caller to arrange for the process to be reaped.",17,null],[11,"get_stack","","A helper to get a kernel stack for this process",17,{"inputs":[{"name":"process"}],"output":null}],[11,"set_state","","Set the state of the process to `s`",17,{"inputs":[{"name":"process"},{"name":"state"}],"output":null}],[11,"drop","","When the process is reaped, we must free its stack",17,{"inputs":[{"name":"process"}],"output":null}],[11,"fmt","","Allow processes to be printed elegantly in format strings",17,{"inputs":[{"name":"process"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","Two processes are the same if they have the same PID",17,{"inputs":[{"name":"process"},{"name":"process"}],"output":{"name":"bool"}}],[0,"vga","rustcode","This module contains a primitive display driver for the kernel\nwhile in VGA mode.",null,null],[0,"vga","rustcode::vga","A module for VGA buffer manipulation",null,null],[3,"VGAChar","rustcode::vga::vga","Represents a single character in the VGA buffer.\nThe first byte represents the ASCII character. The next\n4 bits represent the background color. The last 4 bits\nrepresent the forground color.",null,null],[12,"ch","","",20,null],[12,"color","","",20,null],[3,"VGABuff","","Abstracts the VGA buffer",null,null],[12,"buff","","",21,null],[3,"VGA","","Safe wrapper around unsafe VGA buffer.\nProvides the abstraction of a cursor and \"screen\"",null,null],[12,"fg","","",22,null],[12,"bg","","",22,null],[12,"cursor","","",22,null],[4,"Color","","Colors for VGA display",null,null],[13,"Black","","",23,null],[13,"Blue","","",23,null],[13,"Green","","",23,null],[13,"Cyan","","",23,null],[13,"Red","","",23,null],[13,"Pink","","",23,null],[13,"Brown","","",23,null],[13,"LightGray","","",23,null],[13,"DarkGray","","",23,null],[13,"LightBlue","","",23,null],[13,"LightGreen","","",23,null],[13,"LightCyan","","",23,null],[13,"LightRed","","",23,null],[13,"LightPink","","",23,null],[13,"Yellow","","",23,null],[13,"White","","",23,null],[7,"VGA_BUFFER","","The VGA buffer",null,null],[17,"ROWS","","Number of rows in the VGA buffer",null,null],[17,"COLS","","Number of columns in the VGA buffer",null,null],[17,"VGA_CMD","","The VGA command port",null,null],[17,"VGA_DATA","","The VGA data port",null,null],[11,"clone","","",23,{"inputs":[{"name":"color"}],"output":{"name":"color"}}],[11,"clone","","",20,{"inputs":[{"name":"vgachar"}],"output":{"name":"vgachar"}}],[11,"clone","","",21,{"inputs":[{"name":"vgabuff"}],"output":{"name":"vgabuff"}}],[11,"clone","","",22,{"inputs":[{"name":"vga"}],"output":{"name":"vga"}}],[11,"set_fg","","Set the forground color of the character",20,{"inputs":[{"name":"vgachar"},{"name":"color"}],"output":null}],[11,"set_bg","","Set the background color of the character",20,{"inputs":[{"name":"vgachar"},{"name":"color"}],"output":null}],[11,"set_char","","Set the ASCII character",20,{"inputs":[{"name":"vgachar"},{"name":"char"}],"output":null}],[11,"index","","",21,null],[11,"index_mut","","",21,null],[11,"new","","Create a new VGA handle",22,{"inputs":[{"name":"vga"}],"output":{"name":"vga"}}],[11,"fill_rect","","Clear the rectangle and paint it with the background color",22,null],[11,"clear_screen","","Paint the whole screen black",22,{"inputs":[{"name":"vga"}],"output":null}],[11,"put_char","","Set character at the cursor",22,{"inputs":[{"name":"vga"},{"name":"char"}],"output":null}],[11,"set_fg","","Set foreground color of the cursor",22,{"inputs":[{"name":"vga"},{"name":"color"}],"output":null}],[11,"set_bg","","Set background color of the cursor",22,{"inputs":[{"name":"vga"},{"name":"color"}],"output":null}],[11,"set_cursor","","Set position of the cursor",22,null],[0,"window","rustcode::vga","A module for primitive window drawing",null,null],[3,"Window","rustcode::vga::window","The abstration of a window.",null,null],[12,"height","","",24,null],[12,"width","","",24,null],[12,"pos","","",24,null],[12,"cursor","","",24,null],[12,"vga","","",24,null],[4,"Color","","Colors for VGA display",null,null],[13,"Black","","",23,null],[13,"Blue","","",23,null],[13,"Green","","",23,null],[13,"Cyan","","",23,null],[13,"Red","","",23,null],[13,"Pink","","",23,null],[13,"Brown","","",23,null],[13,"LightGray","","",23,null],[13,"DarkGray","","",23,null],[13,"LightBlue","","",23,null],[13,"LightGreen","","",23,null],[13,"LightCyan","","",23,null],[13,"LightRed","","",23,null],[13,"LightPink","","",23,null],[13,"Yellow","","",23,null],[13,"White","","",23,null],[11,"clone","","",24,{"inputs":[{"name":"window"}],"output":{"name":"window"}}],[11,"new","","Create a new Window.",24,null],[11,"clear_screen","","A static method to clear the screen.",24,{"inputs":[{"name":"window"}],"output":null}],[11,"paint","","Paint the window with the background color",24,{"inputs":[{"name":"window"}],"output":null}],[11,"put_char","","Draw the character at the cursor relative to the corner of window\nif the character is inside the window.",24,{"inputs":[{"name":"window"},{"name":"char"}],"output":null}],[11,"put_str","","Render the string at the cursor using word wrapping.",24,{"inputs":[{"name":"window"},{"name":"str"}],"output":null}],[11,"set_fg","","Set the foreground color",24,{"inputs":[{"name":"window"},{"name":"color"}],"output":null}],[11,"set_bg","","Set the background color",24,{"inputs":[{"name":"window"},{"name":"color"}],"output":null}],[11,"set_cursor","","Set the cursor position",24,null],[0,"interrupts","rustcode","This module contains everything needed for interrupts",null,null],[5,"on","rustcode::interrupts","Turn interrupts on",null,{"inputs":[],"output":null}],[5,"off","","Turn interrupts off",null,{"inputs":[],"output":null}],[5,"add_trap_handler","","Register a trap handler for the given trap number with the given privelege level",null,null],[5,"init","","Initialize interrupts. Set the PIT frequency to `pit_hz`",null,{"inputs":[{"name":"usize"}],"output":null}],[0,"idt","","This module contains IDT stuff",null,null],[3,"TableDescriptor","rustcode::interrupts::idt","A descriptor for use in with instructions like `lgdt` or `lidt`",null,null],[12,"size","","",25,null],[12,"location","","",25,null],[3,"IDTDescr","","An entry in the IDT",null,null],[12,"offset_1","","",26,null],[12,"selector","","",26,null],[12,"zero","","",26,null],[12,"type_attr","","",26,null],[12,"offset_2","","",26,null],[5,"add_interrupt_handler","","Register an interrupt handler for the given IRQ number",null,null],[5,"add_trap_handler","","Register a trap handler for the given trap number with the given privelege level",null,null],[7,"kernelCodeSeg","","",null,null],[7,"idt","","",null,null],[11,"clone","","",25,{"inputs":[{"name":"tabledescriptor"}],"output":{"name":"tabledescriptor"}}],[11,"clone","","",26,{"inputs":[{"name":"idtdescr"}],"output":{"name":"idtdescr"}}],[11,"new","","Create an empty `IDTDescr`",26,{"inputs":[{"name":"idtdescr"}],"output":{"name":"idtdescr"}}],[11,"set_offset","","Set the offset of the descriptor to `offset`",26,{"inputs":[{"name":"idtdescr"},{"name":"u32"}],"output":null}],[11,"set_type_attr","","Set the type and attributes of the descriptor",26,{"inputs":[{"name":"idtdescr"},{"name":"bool"},{"name":"u8"},{"name":"bool"},{"name":"u8"}],"output":null}],[11,"set_selector","","Set the segment selector of the descriptor",26,{"inputs":[{"name":"idtdescr"},{"name":"u16"}],"output":null}],[0,"process","rustcode::interrupts","Module for cleanly turning interrupts on and off",null,null],[5,"on","rustcode::interrupts::process","Turn interrupts on",null,{"inputs":[],"output":null}],[5,"off","","Turn interrupts off",null,{"inputs":[],"output":null}],[5,"start_irq","","Helper method for use in IRQ\nBookkeeping to start an irq.\nThis should never happen if there is no current process.",null,{"inputs":[],"output":null}],[5,"end_irq","","Helper method for use in IRQ\nBookkeeping to end an irq",null,{"inputs":[],"output":null}],[0,"pit","rustcode::interrupts","A module for the programmable interrupt timer",null,null],[5,"init","rustcode::interrupts::pit","Initialize the PIT to the given frequency",null,{"inputs":[{"name":"usize"}],"output":null}],[5,"handler","","Handle a PIT interrupt. Increments `JIFFIES`",null,{"inputs":[],"output":null}],[5,"seconds","","Calculate the number of seconds since boot",null,{"inputs":[],"output":{"name":"usize"}}],[7,"hz","","The frequency of the PIT",null,null],[7,"JIFFIES","","The number of jiffies passed since boot",null,null],[17,"FREQ","","Max frequency of the PIT",null,null],[0,"pic","rustcode::interrupts","A module for programmable interrupt controller",null,null],[5,"init","rustcode::interrupts::pic","Initialize the PIC, but leave interrupts disabled",null,{"inputs":[],"output":null}],[5,"pic_eoi","","End of interrupt: send the next irq, but interrupts still disabled",null,{"inputs":[{"name":"u8"}],"output":null}],[5,"pic_irq","","Rust-side IRQ handling code",null,{"inputs":[{"name":"usize"}],"output":null}],[17,"C1","","Command port for PIC1",null,null],[17,"D1","","Data port for PIC1",null,null],[17,"C2","","Command port for PIC2",null,null],[17,"D2","","Data port for PIC2",null,null],[17,"FIRST_IDT","","First IRQ number allowed for registering handlers",null,null],[14,"printf!","rustcode","A macro for printing using format strings to the console\nwhen interrupts are enabled",null,null],[14,"bootlog!","","A macro for printing using format strings to the console\nwhen interrupts are not enabled",null,null]],"paths":[[3,"Debug"],[3,"ProcessQueue"],[3,"Semaphore"],[3,"StaticSemaphore"],[3,"SemaphoreGuard"],[3,"AddressSpace"],[3,"Block"],[3,"TSSDescriptor"],[3,"TSS"],[3,"Frame"],[3,"FrameInfoSection"],[3,"FrameInfo"],[3,"PagingEntry"],[3,"VMTable"],[3,"MemoryListEntry"],[3,"Region"],[3,"RegionMap"],[3,"Process"],[4,"State"],[3,"KContext"],[3,"VGAChar"],[3,"VGABuff"],[3,"VGA"],[4,"Color"],[3,"Window"],[3,"TableDescriptor"],[3,"IDTDescr"]]};
initSearch(searchIndex);
