var searchIndex = {};
searchIndex['os1'] = {"items":[[0,"","os1","The os1 kernel is written and compiled as a library. It is then\ncompiled and linked together with assembly files to produce a binary.\nThe binary is written to the hard disk, which is then loaded.",null,null],[5,"store_kcontext","","Save the `KContext` of the current process to its process struct",null,null],[5,"_proc_yield","","The unsafe function that does the actual work of choosing the\nnext process and switching to it.",null,{"inputs":[{"name":"option"}],"output":null}],[5,"pic_irq","","Rust-side IRQ handling code",null,{"inputs":[{"name":"usize"}],"output":null}],[5,"vmm_page_fault","","The Rust-side code of the page fault handler.",null,{"inputs":[{"name":"usize"}],"output":null}],[5,"kernel_main","","This is the entry point to the kernel. It is the first rust code that runs.",null,{"inputs":[],"output":null}],[0,"debug","","This module allows the user to print to QEMU's serial console.",null,null],[3,"Debug","os1::debug","A struct to write data to the console port",null,null],[17,"PORT","","Port to output to serial console",null,null],[11,"write_bytes","","Wait for the port, then write the given array of bytes",0,null],[11,"write_str","","Take a string slice and write to the serial console",0,{"inputs":[{"name":"debug"},{"name":"str"}],"output":{"name":"result"}}],[0,"bare_bones","os1","This module contains some basic functionality that libstd would normally\notherwise provide. Most importantly, it defines `rust_begin_unwind` which is\nused by `panic!`.",null,null],[5,"stack_exhausted","os1::bare_bones","",null,{"inputs":[],"output":null}],[5,"eh_personality","","",null,{"inputs":[],"output":null}],[5,"rust_begin_unwind","","This function is used by `panic!` to display an error message.",null,{"inputs":[{"name":"arguments"},{"name":"str"},{"name":"u32"}],"output":null}],[0,"linked_list","os1","A doubly-linked list with owned nodes modified slightly from the std library.",null,null],[3,"LinkedList","os1::linked_list","A doubly-linked list.",null,null],[12,"length","","",1,null],[12,"list_head","","",1,null],[12,"list_tail","","",1,null],[3,"Rawlink","","",null,null],[12,"p","","",2,null],[3,"Node","","",null,null],[12,"next","","",3,null],[12,"prev","","",3,null],[12,"value","","",3,null],[3,"Iter","","An iterator over references to the items of a `LinkedList`.",null,null],[12,"head","","",4,null],[12,"tail","","",4,null],[12,"nelem","","",4,null],[3,"IterMut","","An iterator over mutable references to the items of a `LinkedList`.",null,null],[12,"list","","",5,null],[12,"head","","",5,null],[12,"tail","","",5,null],[12,"nelem","","",5,null],[3,"IntoIter","","An iterator over mutable references to the items of a `LinkedList`.",null,null],[12,"list","","",6,null],[5,"link_no_prev","","Clear the .prev field on `next`, then return `Some(next)`",null,{"inputs":[{"name":"box"}],"output":{"name":"link"}}],[6,"Link","","",null,null],[11,"clone","","",4,{"inputs":[{"name":"iter"}],"output":{"name":"iter"}}],[11,"clone","","",6,{"inputs":[{"name":"intoiter"}],"output":{"name":"intoiter"}}],[11,"none","","Like Option::None for Rawlink",2,{"inputs":[{"name":"rawlink"}],"output":{"name":"rawlink"}}],[11,"some","","Like Option::Some for Rawlink",2,{"inputs":[{"name":"rawlink"},{"name":"t"}],"output":{"name":"rawlink"}}],[11,"resolve","","Convert the `Rawlink` into an Option value",2,{"inputs":[{"name":"rawlink"}],"output":{"name":"option"}}],[11,"resolve_mut","","Convert the `Rawlink` into an Option value",2,{"inputs":[{"name":"rawlink"}],"output":{"name":"option"}}],[11,"take","","Return the `Rawlink` and replace with `Rawlink::none()`",2,{"inputs":[{"name":"rawlink"}],"output":{"name":"rawlink"}}],[11,"from","","",2,{"inputs":[{"name":"rawlink"},{"name":"link"}],"output":{"name":"self"}}],[11,"clone","","",2,{"inputs":[{"name":"rawlink"}],"output":{"name":"rawlink"}}],[11,"new","","",3,{"inputs":[{"name":"node"},{"name":"t"}],"output":{"name":"node"}}],[11,"set_next","","Update the `prev` link on `next`, then set self's next pointer.",3,{"inputs":[{"name":"node"},{"name":"box"}],"output":null}],[11,"push_front_node","","Add a Node first in the list",1,{"inputs":[{"name":"linkedlist"},{"name":"box"}],"output":null}],[11,"pop_front_node","","Remove the first Node and return it, or None if the list is empty",1,{"inputs":[{"name":"linkedlist"}],"output":{"name":"option"}}],[11,"push_back_node","","Add a Node last in the list",1,{"inputs":[{"name":"linkedlist"},{"name":"box"}],"output":null}],[11,"pop_back_node","","Remove the last Node and return it, or None if the list is empty",1,{"inputs":[{"name":"linkedlist"}],"output":{"name":"option"}}],[11,"default","","",1,{"inputs":[{"name":"linkedlist"}],"output":{"name":"linkedlist"}}],[11,"new","","Creates an empty `LinkedList`.",1,{"inputs":[{"name":"linkedlist"}],"output":{"name":"linkedlist"}}],[11,"append","","Moves all elements from `other` to the end of the list.",1,{"inputs":[{"name":"linkedlist"},{"name":"linkedlist"}],"output":null}],[11,"iter","","Provides a forward iterator.",1,{"inputs":[{"name":"linkedlist"}],"output":{"name":"iter"}}],[11,"iter_mut","","Provides a forward iterator with mutable references.",1,{"inputs":[{"name":"linkedlist"}],"output":{"name":"itermut"}}],[11,"is_empty","","Returns `true` if the `LinkedList` is empty.",1,{"inputs":[{"name":"linkedlist"}],"output":{"name":"bool"}}],[11,"len","","Returns the length of the `LinkedList`.",1,{"inputs":[{"name":"linkedlist"}],"output":{"name":"usize"}}],[11,"clear","","Removes all elements from the `LinkedList`.",1,{"inputs":[{"name":"linkedlist"}],"output":null}],[11,"front","","Provides a reference to the front element, or `None` if the list is\nempty.",1,{"inputs":[{"name":"linkedlist"}],"output":{"name":"option"}}],[11,"front_mut","","Provides a mutable reference to the front element, or `None` if the list\nis empty.",1,{"inputs":[{"name":"linkedlist"}],"output":{"name":"option"}}],[11,"back","","Provides a reference to the back element, or `None` if the list is\nempty.",1,{"inputs":[{"name":"linkedlist"}],"output":{"name":"option"}}],[11,"back_mut","","Provides a mutable reference to the back element, or `None` if the list\nis empty.",1,{"inputs":[{"name":"linkedlist"}],"output":{"name":"option"}}],[11,"push_front","","Adds an element first in the list.",1,{"inputs":[{"name":"linkedlist"},{"name":"t"}],"output":null}],[11,"pop_front","","Removes the first element and returns it, or `None` if the list is\nempty.",1,{"inputs":[{"name":"linkedlist"}],"output":{"name":"option"}}],[11,"push_back","","Appends an element to the back of a list",1,{"inputs":[{"name":"linkedlist"},{"name":"t"}],"output":null}],[11,"pop_back","","Removes the last element from a list and returns it, or `None` if\nit is empty.",1,{"inputs":[{"name":"linkedlist"}],"output":{"name":"option"}}],[11,"split_off","","Splits the list into two at the given index. Returns everything after the given index,\nincluding the index.",1,{"inputs":[{"name":"linkedlist"},{"name":"usize"}],"output":{"name":"linkedlist"}}],[11,"drop","","",1,{"inputs":[{"name":"linkedlist"}],"output":null}],[11,"next","","",4,{"inputs":[{"name":"iter"}],"output":{"name":"option"}}],[11,"size_hint","","",4,null],[11,"next_back","","",4,{"inputs":[{"name":"iter"}],"output":{"name":"option"}}],[11,"next","","",5,{"inputs":[{"name":"itermut"}],"output":{"name":"option"}}],[11,"size_hint","","",5,null],[11,"next_back","","",5,{"inputs":[{"name":"itermut"}],"output":{"name":"option"}}],[11,"insert_next_node","","",5,{"inputs":[{"name":"itermut"},{"name":"box"}],"output":null}],[11,"insert_next","","Inserts `elt` just after the element most recently returned by `.next()`.\nThe inserted element does not appear in the iteration.",5,{"inputs":[{"name":"itermut"},{"name":"a"}],"output":null}],[11,"peek_next","","Provides a reference to the next element, without changing the iterator.",5,{"inputs":[{"name":"itermut"}],"output":{"name":"option"}}],[11,"next","","",6,{"inputs":[{"name":"intoiter"}],"output":{"name":"option"}}],[11,"size_hint","","",6,null],[11,"next_back","","",6,{"inputs":[{"name":"intoiter"}],"output":{"name":"option"}}],[11,"from_iter","","",1,{"inputs":[{"name":"linkedlist"},{"name":"t"}],"output":{"name":"linkedlist"}}],[11,"into_iter","","Consumes the list into an iterator yielding elements by value.",1,{"inputs":[{"name":"linkedlist"}],"output":{"name":"intoiter"}}],[11,"extend","","",1,{"inputs":[{"name":"linkedlist"},{"name":"t"}],"output":null}],[11,"extend","","",1,{"inputs":[{"name":"linkedlist"},{"name":"i"}],"output":null}],[11,"eq","","",1,{"inputs":[{"name":"linkedlist"},{"name":"linkedlist"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"linkedlist"},{"name":"linkedlist"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",1,{"inputs":[{"name":"linkedlist"},{"name":"linkedlist"}],"output":{"name":"option"}}],[11,"cmp","","",1,{"inputs":[{"name":"linkedlist"},{"name":"linkedlist"}],"output":{"name":"ordering"}}],[11,"clone","","",1,{"inputs":[{"name":"linkedlist"}],"output":{"name":"linkedlist"}}],[11,"fmt","","",1,{"inputs":[{"name":"linkedlist"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hash","","",1,{"inputs":[{"name":"linkedlist"},{"name":"h"}],"output":null}],[0,"static_linked_list","os1","A doubly-linked list with owned nodes modified slightly from the std library.\nThis version can be used in statics and has a const constructor.",null,null],[3,"StaticLinkedList","os1::static_linked_list","A doubly-linked list.",null,null],[12,"length","","",7,null],[12,"list_head","","",7,null],[12,"list_tail","","",7,null],[3,"Rawlink","","",null,null],[12,"p","","",8,null],[3,"Node","","",null,null],[12,"next","","",9,null],[12,"prev","","",9,null],[12,"value","","",9,null],[3,"Iter","","An iterator over references to the items of a `StaticLinkedList`.",null,null],[12,"head","","",10,null],[12,"tail","","",10,null],[12,"nelem","","",10,null],[3,"IterMut","","An iterator over mutable references to the items of a `StaticLinkedList`.",null,null],[12,"list","","",11,null],[12,"head","","",11,null],[12,"tail","","",11,null],[12,"nelem","","",11,null],[3,"IntoIter","","An iterator over mutable references to the items of a `StaticLinkedList`.",null,null],[12,"list","","",12,null],[5,"link_no_prev","","Clear the .prev field on `next`, then return `Some(next)`",null,{"inputs":[{"name":"box"}],"output":{"name":"link"}}],[6,"Link","","",null,null],[11,"clone","","",10,{"inputs":[{"name":"iter"}],"output":{"name":"iter"}}],[11,"clone","","",12,{"inputs":[{"name":"intoiter"}],"output":{"name":"intoiter"}}],[11,"none","","Like Option::None for Rawlink",8,{"inputs":[{"name":"rawlink"}],"output":{"name":"rawlink"}}],[11,"some","","Like Option::Some for Rawlink",8,{"inputs":[{"name":"rawlink"},{"name":"t"}],"output":{"name":"rawlink"}}],[11,"resolve","","Convert the `Rawlink` into an Option value",8,{"inputs":[{"name":"rawlink"}],"output":{"name":"option"}}],[11,"resolve_mut","","Convert the `Rawlink` into an Option value",8,{"inputs":[{"name":"rawlink"}],"output":{"name":"option"}}],[11,"take","","Return the `Rawlink` and replace with `Rawlink::none()`",8,{"inputs":[{"name":"rawlink"}],"output":{"name":"rawlink"}}],[11,"from","","",8,{"inputs":[{"name":"rawlink"},{"name":"link"}],"output":{"name":"self"}}],[11,"clone","","",8,{"inputs":[{"name":"rawlink"}],"output":{"name":"rawlink"}}],[11,"new","","",9,{"inputs":[{"name":"node"},{"name":"t"}],"output":{"name":"node"}}],[11,"set_next","","Update the `prev` link on `next`, then set self's next pointer.",9,{"inputs":[{"name":"node"},{"name":"box"}],"output":null}],[11,"push_front_node","","Add a Node first in the list",7,{"inputs":[{"name":"staticlinkedlist"},{"name":"box"}],"output":null}],[11,"pop_front_node","","Remove the first Node and return it, or None if the list is empty",7,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"link"}}],[11,"push_back_node","","Add a Node last in the list",7,{"inputs":[{"name":"staticlinkedlist"},{"name":"box"}],"output":null}],[11,"pop_back_node","","Remove the last Node and return it, or None if the list is empty",7,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"link"}}],[11,"default","","",7,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"staticlinkedlist"}}],[11,"new","","Creates an empty `StaticLinkedList`.",7,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"staticlinkedlist"}}],[11,"append","","Moves all elements from `other` to the end of the list.",7,{"inputs":[{"name":"staticlinkedlist"},{"name":"staticlinkedlist"}],"output":null}],[11,"iter","","Provides a forward iterator.",7,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"iter"}}],[11,"iter_mut","","Provides a forward iterator with mutable references.",7,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"itermut"}}],[11,"is_empty","","Returns `true` if the `StaticLinkedList` is empty.",7,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"bool"}}],[11,"len","","Returns the length of the `StaticLinkedList`.",7,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"usize"}}],[11,"clear","","Removes all elements from the `StaticLinkedList`.",7,{"inputs":[{"name":"staticlinkedlist"}],"output":null}],[11,"front","","Provides a reference to the front element, or `None` if the list is\nempty.",7,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"option"}}],[11,"front_mut","","Provides a mutable reference to the front element, or `None` if the list\nis empty.",7,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"option"}}],[11,"back","","Provides a reference to the back element, or `None` if the list is\nempty.",7,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"option"}}],[11,"back_mut","","Provides a mutable reference to the back element, or `None` if the list\nis empty.",7,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"option"}}],[11,"push_front","","Adds an element first in the list.",7,{"inputs":[{"name":"staticlinkedlist"},{"name":"t"}],"output":null}],[11,"pop_front","","Removes the first element and returns it, or `None` if the list is\nempty.",7,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"option"}}],[11,"push_back","","Appends an element to the back of a list",7,{"inputs":[{"name":"staticlinkedlist"},{"name":"t"}],"output":null}],[11,"pop_back","","Removes the last element from a list and returns it, or `None` if\nit is empty.",7,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"option"}}],[11,"split_off","","Splits the list into two at the given index. Returns everything after the given index,\nincluding the index.",7,{"inputs":[{"name":"staticlinkedlist"},{"name":"usize"}],"output":{"name":"staticlinkedlist"}}],[11,"remove","","Removes the element at the given index and returns it.",7,{"inputs":[{"name":"staticlinkedlist"},{"name":"usize"}],"output":{"name":"t"}}],[11,"next","","",10,{"inputs":[{"name":"iter"}],"output":{"name":"option"}}],[11,"size_hint","","",10,null],[11,"next_back","","",10,{"inputs":[{"name":"iter"}],"output":{"name":"option"}}],[11,"next","","",11,{"inputs":[{"name":"itermut"}],"output":{"name":"option"}}],[11,"size_hint","","",11,null],[11,"next_back","","",11,{"inputs":[{"name":"itermut"}],"output":{"name":"option"}}],[11,"insert_next_node","","",11,{"inputs":[{"name":"itermut"},{"name":"box"}],"output":null}],[11,"insert_next","","Inserts `elt` just after the element most recently returned by `.next()`.\nThe inserted element does not appear in the iteration.",11,{"inputs":[{"name":"itermut"},{"name":"a"}],"output":null}],[11,"peek_next","","Provides a reference to the next element, without changing the iterator.",11,{"inputs":[{"name":"itermut"}],"output":{"name":"option"}}],[11,"next","","",12,{"inputs":[{"name":"intoiter"}],"output":{"name":"option"}}],[11,"size_hint","","",12,null],[11,"next_back","","",12,{"inputs":[{"name":"intoiter"}],"output":{"name":"option"}}],[11,"from_iter","","",7,{"inputs":[{"name":"staticlinkedlist"},{"name":"t"}],"output":{"name":"staticlinkedlist"}}],[11,"into_iter","","Consumes the list into an iterator yielding elements by value.",7,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"intoiter"}}],[11,"extend","","",7,{"inputs":[{"name":"staticlinkedlist"},{"name":"t"}],"output":null}],[11,"extend","","",7,{"inputs":[{"name":"staticlinkedlist"},{"name":"i"}],"output":null}],[11,"eq","","",7,{"inputs":[{"name":"staticlinkedlist"},{"name":"staticlinkedlist"}],"output":{"name":"bool"}}],[11,"ne","","",7,{"inputs":[{"name":"staticlinkedlist"},{"name":"staticlinkedlist"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",7,{"inputs":[{"name":"staticlinkedlist"},{"name":"staticlinkedlist"}],"output":{"name":"option"}}],[11,"cmp","","",7,{"inputs":[{"name":"staticlinkedlist"},{"name":"staticlinkedlist"}],"output":{"name":"ordering"}}],[11,"clone","","",7,{"inputs":[{"name":"staticlinkedlist"}],"output":{"name":"staticlinkedlist"}}],[11,"fmt","","",7,{"inputs":[{"name":"staticlinkedlist"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hash","","",7,{"inputs":[{"name":"staticlinkedlist"},{"name":"h"}],"output":null}],[0,"vec","os1","A simple vector implementation",null,null],[3,"Vec","os1::vec","A vector implementation.\n- Amortized O(1) push to end\n- O(1) pop from end\n- O(1) access to any element\n- Automatic memory management\n- Indexable with [] operator",null,null],[12,"buf","","",13,null],[12,"len","","",13,null],[3,"IntoIter","","An iterator that moves out of a vector modified from the stdlib",null,null],[12,"_buf","","",14,null],[12,"ptr","","",14,null],[12,"end","","",14,null],[11,"new","","Create a new empty vector",13,{"inputs":[{"name":"vec"}],"output":{"name":"vec"}}],[11,"push","","Push the element to the end",13,{"inputs":[{"name":"vec"},{"name":"t"}],"output":null}],[11,"pop","","Pop and return the last element",13,{"inputs":[{"name":"vec"}],"output":{"name":"option"}}],[11,"len","","Return the number of elements",13,{"inputs":[{"name":"vec"}],"output":{"name":"usize"}}],[11,"truncate","","Shorten a vector to be `len` elements long, dropping excess elements.",13,{"inputs":[{"name":"vec"},{"name":"usize"}],"output":null}],[11,"index","","",13,{"inputs":[{"name":"vec"},{"name":"usize"}],"output":{"name":"t"}}],[11,"index_mut","","",13,{"inputs":[{"name":"vec"},{"name":"usize"}],"output":{"name":"t"}}],[11,"drop","","",13,{"inputs":[{"name":"vec"}],"output":null}],[11,"deref","","",13,null],[11,"deref_mut","","",13,null],[11,"clone","","",13,{"inputs":[{"name":"vec"}],"output":{"name":"vec"}}],[11,"clone_from","","",13,{"inputs":[{"name":"vec"},{"name":"vec"}],"output":null}],[11,"into_iter","","Creates a consuming iterator, that is, one that moves each value out of\nthe vector (from start to end). The vector cannot be used after calling\nthis.",13,{"inputs":[{"name":"vec"}],"output":{"name":"intoiter"}}],[11,"next","","",14,{"inputs":[{"name":"intoiter"}],"output":{"name":"option"}}],[11,"size_hint","","",14,null],[11,"count","","",14,{"inputs":[{"name":"intoiter"}],"output":{"name":"usize"}}],[0,"string","os1","A simple String implementation",null,null],[3,"String","os1::string","A growable UTF-8 string",null,null],[12,"vec","","",15,null],[11,"new","","Return a new empty string: \"\"",15,{"inputs":[{"name":"string"}],"output":{"name":"string"}}],[11,"push","","Push a character to the end",15,{"inputs":[{"name":"string"},{"name":"char"}],"output":null}],[11,"pop","","Pop and return the last character",15,{"inputs":[{"name":"string"}],"output":{"name":"option"}}],[11,"len","","",15,{"inputs":[{"name":"string"}],"output":{"name":"usize"}}],[11,"deref","","",15,{"inputs":[{"name":"string"}],"output":{"name":"str"}}],[11,"fmt","","",15,{"inputs":[{"name":"string"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",15,{"inputs":[{"name":"string"}],"output":{"name":"self"}}],[11,"clone_from","","",15,{"inputs":[{"name":"string"},{"name":"self"}],"output":null}],[0,"fs","os1","A module for file system stuff",null,null],[5,"init","os1::fs","Initialize the root file system from the given device",null,{"inputs":[{"name":"ide"}],"output":null}],[0,"ofs","","A module for os1 FS (OFS)",null,null],[0,"fs","os1::fs::ofs","A module for OFS abstractions",null,null],[3,"OFSHandle","os1::fs::ofs::fs","A safe handle on the file system for all needed operations.",null,null],[12,"fs","","",16,null],[3,"OFS","","The OFS interface",null,null],[12,"device","","",17,null],[12,"meta","","",17,null],[3,"File","","A handle on the file for all needed operations.",null,null],[12,"inode_num","","",18,null],[12,"inode","","",18,null],[12,"offset","","",18,null],[12,"offset_dnode","","",18,null],[12,"ofs","","",18,null],[11,"new","","Create a new handle on the fs using the device",16,{"inputs":[{"name":"ofshandle"},{"name":"b"}],"output":{"name":"ofshandle"}}],[11,"open","","Open the file with the given inode number and return a handle to it.",16,{"inputs":[{"name":"ofshandle"},{"name":"usize"}],"output":{"name":"result"}}],[11,"link","","Create a link (directed edge) from file `a` to file `b`. `a` and `b` are the inode number\nof the files.",16,{"inputs":[{"name":"ofshandle"},{"name":"usize"},{"name":"usize"}],"output":{"name":"option"}}],[11,"unlink","","Remove a link (directed edge) from file `a` to file `b`. `a` and `b` are the inode number\nof the files.",16,{"inputs":[{"name":"ofshandle"},{"name":"usize"},{"name":"usize"}],"output":{"name":"option"}}],[11,"stat","","Return metadata for the file with inode `a` or None if the file does not exist",16,{"inputs":[{"name":"ofshandle"},{"name":"usize"}],"output":{"name":"option"}}],[11,"new_file","","Create a new file and a link from `a` to it. `a` is the inode number of the file. Return\nthe inode number of the new file.",16,{"inputs":[{"name":"ofshandle"}],"output":{"name":"result"}}],[11,"delete_file","","Delete file `a`. `a` is the inode number of the file.",16,{"inputs":[{"name":"ofshandle"},{"name":"usize"}],"output":{"name":"option"}}],[11,"get_inode_start_sector","","Get the sector number of the first inode",17,{"inputs":[{"name":"ofs"}],"output":{"name":"usize"}}],[11,"get_dnode_start_sector","","Get the sector number of the first dnode.",17,{"inputs":[{"name":"ofs"}],"output":{"name":"usize"}}],[11,"get_inode_offset","","Get the disk offset of the `i`th inode.",17,{"inputs":[{"name":"ofs"},{"name":"usize"}],"output":{"name":"usize"}}],[11,"get_dnode_offset","","Get the disk offset of the `d`th dnode.",17,{"inputs":[{"name":"ofs"},{"name":"usize"}],"output":{"name":"usize"}}],[11,"get_inode","","Get the `i`th inode",17,{"inputs":[{"name":"ofs"},{"name":"usize"}],"output":{"name":"inode"}}],[11,"get_dnode","","Get the `d`th dnode",17,{"inputs":[{"name":"ofs"},{"name":"usize"}],"output":{"name":"dnode"}}],[11,"get_new_inode","","Allocate a new inode and return its index",17,{"inputs":[{"name":"ofs"}],"output":{"name":"usize"}}],[11,"get_new_dnode","","Allocate a new dnode and return its index",17,{"inputs":[{"name":"ofs"}],"output":{"name":"usize"}}],[11,"is_file","","Returns true if the file exists.",17,{"inputs":[{"name":"ofs"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"get_filename","","Return the filename",18,{"inputs":[{"name":"file"}],"output":{"name":"string"}}],[11,"read_part","","Read from the file at the file offset into the buffer at the buffer offset.  This method\nwill not overflow the buffer or read past the end of the file, but it might not read as\nmuch as possible from the file, even if the buffer is not full. This updates both the\nfile offset and the buffer offset.",18,{"inputs":[{"name":"file"},{"name":"blockdatabuffer"}],"output":{"name":"usize"}}],[11,"write_part","","Write from the buffer at the buffer offset into the file at the file offset, overwriting\nany exisiting content. This method may extend the length of the file. This method might not\nwrite as much as possible from the file. This updates both the file offset and the buffer\noffset.",18,{"inputs":[{"name":"file"},{"name":"usize"},{"name":"blockdatabuffer"}],"output":{"name":"usize"}}],[11,"seek","","Seek into the file to the given `offset`.",18,{"inputs":[{"name":"file"},{"name":"usize"}],"output":null}],[11,"read","","Fill the buffer starting at the buffer offset from the file starting at the file offset.\nThis reads as much as possible from the file without overflowing the buffer or reading past\nthe EOF. This updates both the file and buffer offsets.",18,{"inputs":[{"name":"file"},{"name":"blockdatabuffer"}],"output":{"name":"usize"}}],[11,"write","","Write `bytes` bytes from the buffer at the buffer offset to the file at the file offset,\noverwriting any existing content at the offset.\nThis will increase the length of the file if necessary.  This updates both the file and\nbuffer offsets.",18,{"inputs":[{"name":"file"},{"name":"usize"},{"name":"blockdatabuffer"}],"output":null}],[11,"drop","","Close the file. Write back the inode",18,{"inputs":[{"name":"file"}],"output":null}],[0,"hw","os1::fs::ofs","A module of low-level abstractions for disk-level representations of data for OFS.",null,null],[3,"OFSDate","os1::fs::ofs::hw","A 4B representation of the date for use in the OS",null,null],[12,"date","","",19,null],[3,"Metadata","","The metadata sector of the partition",null,null],[12,"magic","","",20,null],[12,"num_inode","","",20,null],[12,"num_dnode","","",20,null],[3,"Inode","","A single OFS Inode (128B)",null,null],[12,"name","","",21,null],[12,"uid","","",21,null],[12,"gid","","",21,null],[12,"user_perm","","",21,null],[12,"group_perm","","",21,null],[12,"all_perm","","",21,null],[12,"flags","","",21,null],[12,"size","","",21,null],[12,"data","","",21,null],[12,"created","","",21,null],[12,"modified","","",21,null],[12,"links","","",21,null],[3,"Dnode","","A single OFS Dnode (512B)",null,null],[12,"data","","",22,null],[17,"UNNAMED","","",null,null],[11,"clone","","",19,{"inputs":[{"name":"ofsdate"}],"output":{"name":"ofsdate"}}],[11,"clone","","",20,{"inputs":[{"name":"metadata"}],"output":{"name":"metadata"}}],[11,"clone","","",21,{"inputs":[{"name":"inode"}],"output":{"name":"inode"}}],[11,"now","","",19,{"inputs":[{"name":"ofsdate"}],"output":{"name":"ofsdate"}}],[11,"get_magic_str","","Get the magic string of as a `String`",20,{"inputs":[{"name":"metadata"}],"output":{"name":"string"}}],[11,"inodes_per_sector","","Get the number of inodes in a sector",21,{"inputs":[{"name":"inode"}],"output":{"name":"usize"}}],[11,"get_filename","","Get the filename as a string",21,{"inputs":[{"name":"inode"}],"output":{"name":"string"}}],[11,"dnodes_per_sector","","Get the number of dnodes in a sector",22,{"inputs":[{"name":"dnode"}],"output":{"name":"usize"}}],[11,"get_next","","Return the last word of this dnode. If the file\nhas another dnode, this will be its index.",22,{"inputs":[{"name":"dnode"}],"output":{"name":"usize"}}],[11,"clone","","",22,{"inputs":[{"name":"dnode"}],"output":{"name":"dnode"}}],[0,"error","os1::fs","A simple Error object for FS errors",null,null],[3,"Error","os1::fs::error","",null,null],[12,"msg","","",23,null],[11,"new","","",23,{"inputs":[{"name":"error"},{"name":"str"}],"output":{"name":"error"}}],[7,"ROOT_FS","os1::fs","",null,null],[0,"interrupts","os1","This module contains everything needed for interrupts",null,null],[5,"add_trap_handler","os1::interrupts","Register a trap handler for the given trap number with the given privelege level",null,null],[5,"on","","Turn interrupts on",null,{"inputs":[],"output":null}],[5,"off","","Turn interrupts off",null,{"inputs":[],"output":null}],[5,"esp0","","",null,{"inputs":[{"name":"usize"}],"output":null}],[5,"tss_init","","",null,{"inputs":[],"output":null}],[5,"init","","Initialize interrupts. Set the PIT frequency to `pit_hz`",null,{"inputs":[{"name":"usize"}],"output":null}],[0,"pic","","A module for programmable interrupt controller",null,null],[5,"init","os1::interrupts::pic","Initialize the PIC, but leave interrupts disabled",null,{"inputs":[],"output":null}],[5,"pic_eoi","","End of interrupt: send the next irq, but interrupts still disabled",null,{"inputs":[{"name":"u8"}],"output":null}],[5,"pic_irq","","Rust-side IRQ handling code",null,{"inputs":[{"name":"usize"}],"output":null}],[17,"C1","","Command port for PIC1",null,null],[17,"D1","","Data port for PIC1",null,null],[17,"C2","","Command port for PIC2",null,null],[17,"D2","","Data port for PIC2",null,null],[17,"FIRST_IDT","","First IRQ number allowed for registering handlers",null,null],[0,"pit","os1::interrupts","A module for the programmable interrupt timer",null,null],[5,"init","os1::interrupts::pit","Initialize the PIT to the given frequency",null,{"inputs":[{"name":"usize"}],"output":null}],[5,"handler","","Handle a PIT interrupt. Increments `JIFFIES`",null,{"inputs":[],"output":null}],[5,"seconds","","Calculate the number of seconds since boot",null,{"inputs":[],"output":{"name":"usize"}}],[7,"hz","","The frequency of the PIT",null,null],[7,"JIFFIES","","The number of jiffies passed since boot",null,null],[17,"FREQ","","Max frequency of the PIT",null,null],[0,"idt","os1::interrupts","This module contains IDT stuff",null,null],[3,"TableDescriptor","os1::interrupts::idt","A descriptor for use in with instructions like `lgdt` or `lidt`",null,null],[12,"size","","",24,null],[12,"location","","",24,null],[3,"IDTDescr","","An entry in the IDT",null,null],[12,"offset_1","","",25,null],[12,"selector","","",25,null],[12,"zero","","",25,null],[12,"type_attr","","",25,null],[12,"offset_2","","",25,null],[5,"add_interrupt_handler","","Register an interrupt handler for the given IRQ number",null,null],[5,"add_trap_handler","","Register a trap handler for the given trap number with the given privelege level",null,null],[7,"kernelCodeSeg","","",null,null],[7,"idt","","",null,null],[11,"clone","","",24,{"inputs":[{"name":"tabledescriptor"}],"output":{"name":"tabledescriptor"}}],[11,"clone","","",25,{"inputs":[{"name":"idtdescr"}],"output":{"name":"idtdescr"}}],[11,"new","","Create an empty `IDTDescr`",25,{"inputs":[{"name":"idtdescr"}],"output":{"name":"idtdescr"}}],[11,"set_offset","","Set the offset of the descriptor to `offset`",25,{"inputs":[{"name":"idtdescr"},{"name":"u32"}],"output":null}],[11,"set_type_attr","","Set the type and attributes of the descriptor",25,{"inputs":[{"name":"idtdescr"},{"name":"bool"},{"name":"u8"},{"name":"bool"},{"name":"u8"}],"output":null}],[11,"set_selector","","Set the segment selector of the descriptor",25,{"inputs":[{"name":"idtdescr"},{"name":"u16"}],"output":null}],[0,"process","os1::interrupts","Module for cleanly turning interrupts on and off",null,null],[5,"on","os1::interrupts::process","Turn interrupts on",null,{"inputs":[],"output":null}],[5,"off","","Turn interrupts off",null,{"inputs":[],"output":null}],[5,"start_irq","","Helper method for use in IRQ\nBookkeeping to start an irq.\nThis should never happen if there is no current process.",null,{"inputs":[],"output":null}],[5,"end_irq","","Helper method for use in IRQ\nBookkeeping to end an irq",null,{"inputs":[],"output":null}],[0,"tss","os1::interrupts","",null,null],[3,"TSSDescriptor","os1::interrupts::tss","",null,null],[12,"f0","","",26,null],[12,"f1","","",26,null],[3,"TSS","","",null,null],[12,"prev","","",27,null],[12,"esp0","","",27,null],[12,"ss0","","",27,null],[12,"esp1","","",27,null],[12,"ss1","","",27,null],[12,"esp2","","",27,null],[12,"ss2","","",27,null],[12,"unused","","",27,null],[5,"init","","",null,{"inputs":[],"output":null}],[5,"esp0","","",null,{"inputs":[{"name":"usize"}],"output":null}],[7,"tssDescriptor","","",null,null],[7,"tssDS","","",null,null],[7,"kernelDataSeg","","",null,null],[7,"TSS_","","",null,null],[11,"set","","",26,{"inputs":[{"name":"tssdescriptor"},{"name":"tss"}],"output":null}],[11,"new","","",27,{"inputs":[{"name":"tss"}],"output":{"name":"tss"}}],[11,"esp0","","",27,{"inputs":[{"name":"tss"},{"name":"usize"}],"output":null}],[0,"io","os1","A module for I/O stuff",null,null],[3,"NonBlockingBuffer","os1::io","A non-blocking circular buffer for use\nby interrupt handlers",null,null],[12,"buffer","","",28,null],[12,"front","","",28,null],[12,"size","","",28,null],[0,"stream","","The abstraction of a stream of data",null,null],[8,"InputStream","os1::io::stream","A trait for input streams, streams that can be used to get input.",null,null],[16,"Output","","The type returned by `get`",29,null],[10,"get","","Get the next `T` from the stream",29,{"inputs":[{"name":"inputstream"}],"output":{"name":"output"}}],[8,"OutputStream","","A trait for output streams, streams that can be used to store output.",null,null],[10,"put","","Put the given `T` in the stream",30,{"inputs":[{"name":"outputstream"},{"name":"t"}],"output":null}],[0,"kbd","os1::io","A module for getting keyboard input",null,null],[5,"handler","os1::io::kbd","The keyboard interrupt handler",null,{"inputs":[],"output":null}],[5,"ul","","Determine if this character is capital or not",null,{"inputs":[{"name":"char"}],"output":{"name":"char"}}],[5,"get_key","","Get a character from the keyboard",null,{"inputs":[],"output":{"name":"option"}}],[7,"SHIFT","","Is this character capital?",null,null],[17,"CAP","","The difference between a capital and lowercase",null,null],[0,"block","os1::io","A module for accessing hard disks",null,null],[3,"BlockDataBuffer","os1::io::block","A data structure for use with block devices The buffer has an internal pointer that can be used\nfor conveniently performing sequential writes or reads to the buffer.  Also, implementors of\nthis trait must also implement `Drop`, preventing memory leaks.",null,null],[12,"buf","","",31,null],[12,"size","","",31,null],[12,"offset","","",31,null],[8,"BlockDevice","","An abstraction over block devices",null,null],[10,"get_block_size","","Get the block size of this block device in bytes",32,{"inputs":[{"name":"blockdevice"}],"output":{"name":"usize"}}],[10,"read_block","","Read the given block into the buffer",32,{"inputs":[{"name":"blockdevice"},{"name":"usize"},{"name":"blockdatabuffer"}],"output":null}],[10,"write_block","","Write the given block from the buffer",32,{"inputs":[{"name":"blockdevice"},{"name":"usize"},{"name":"blockdatabuffer"}],"output":null}],[11,"read","","Read from the block device at `offset` into the given buffer starting at the buffer's\ninternal offset. This method will read no more data than will fit into the remaining space\nin the buffer, but it may also read less. It will update the buffer's offset, and return\nthe number of bytes read.",32,{"inputs":[{"name":"blockdevice"},{"name":"usize"},{"name":"blockdatabuffer"}],"output":{"name":"usize"}}],[11,"write","","Write from the buffer to the disk starting at the buffer's internal offset. This may not\nwrite the whole buffer. This will update the buffer's offset, and return the number of\nbytes written.",32,{"inputs":[{"name":"blockdevice"},{"name":"usize"},{"name":"blockdatabuffer"}],"output":{"name":"usize"}}],[11,"read_fully","","Read from the block device at `offset` into the given buffer starting at the buffer's\ninternal offset. This method will fill the remaining space in the buffer. It will update\nthe buffer's offset.",32,{"inputs":[{"name":"blockdevice"},{"name":"usize"},{"name":"blockdatabuffer"}],"output":null}],[11,"write_fully","","Write from the buffer to the disk starting at the buffer's internal offset. This will\nwrite the whole buffer. This will update the buffer's offset.",32,{"inputs":[{"name":"blockdevice"},{"name":"usize"},{"name":"blockdatabuffer"}],"output":null}],[11,"read_exactly","","Read `bytes` bytes from the block device at `offset` into the given buffer starting at the\nbuffer's internal offset. This method will fill the remaining space in the buffer. It will\nupdate the buffer's offset.",32,{"inputs":[{"name":"blockdevice"},{"name":"usize"},{"name":"usize"},{"name":"blockdatabuffer"}],"output":null}],[11,"write_exactly","","Write `bytes` bytes to the block device at `offset` from the given buffer starting at the\nbuffer's internal offset. This method will overwrite the existing disk contents. It will\nupdate the buffer's offset.",32,{"inputs":[{"name":"blockdevice"},{"name":"usize"},{"name":"usize"},{"name":"blockdatabuffer"}],"output":null}],[11,"new","","Create a new buffer with the given capacity",31,{"inputs":[{"name":"blockdatabuffer"},{"name":"usize"}],"output":{"name":"blockdatabuffer"}}],[11,"offset","","Get the internal offset in bytes into this buffer",31,{"inputs":[{"name":"blockdatabuffer"}],"output":{"name":"usize"}}],[11,"set_offset","","Set the internal offset in bytes into this buffer",31,{"inputs":[{"name":"blockdatabuffer"},{"name":"usize"}],"output":null}],[11,"size","","Get the size of this buffer in bytes",31,{"inputs":[{"name":"blockdatabuffer"}],"output":{"name":"usize"}}],[11,"get_ptr","","Get a pointer of the given type to the\noffset in the buffer. The offset is relative to the\nsize of `T`",31,null],[11,"get_ref","","Get a reference of the given type to the offset\nin the buffer. The offset is relative to the\nsize of `T`",31,{"inputs":[{"name":"blockdatabuffer"},{"name":"usize"}],"output":{"name":"t"}}],[11,"get_ref_mut","","Get a mutable reference of the given type to the offset\nin the buffer. The offset is relative to the\nsize of `T`",31,{"inputs":[{"name":"blockdatabuffer"},{"name":"usize"}],"output":{"name":"t"}}],[11,"drop","","",31,{"inputs":[{"name":"blockdatabuffer"}],"output":null}],[0,"ide","os1::io","A module for accessing IDE block devices via PIO\nTODO: Add DMA support for performance",null,null],[3,"IDE","os1::io::ide","An abstraction of an IDE block device",null,null],[12,"drive","","",33,null],[12,"lock","","",33,null],[4,"IDEStatus","","IDE drive status",null,null],[13,"BUSY","","",34,null],[13,"READY","","",34,null],[13,"WTFLT","","",34,null],[13,"SCMPL","","",34,null],[13,"DRQ","","",34,null],[13,"CORR","","",34,null],[13,"IDX","","",34,null],[13,"ERR","","",34,null],[17,"SECTOR_SIZE","","The size of a sector",null,null],[17,"PORTS","","The base I/O port for each controller",null,null],[11,"eq","","",34,{"inputs":[{"name":"idestatus"},{"name":"idestatus"}],"output":{"name":"bool"}}],[11,"ne","","",34,{"inputs":[{"name":"idestatus"},{"name":"idestatus"}],"output":{"name":"bool"}}],[11,"new","","",33,{"inputs":[{"name":"ide"},{"name":"u16"}],"output":{"name":"ide"}}],[11,"controller","","Get the controller for the drive",33,{"inputs":[{"name":"ide"}],"output":{"name":"u16"}}],[11,"channel","","Get the channel for the drive",33,{"inputs":[{"name":"ide"}],"output":{"name":"u16"}}],[11,"port","","Get the port for the drive",33,{"inputs":[{"name":"ide"}],"output":{"name":"u16"}}],[11,"get_status","","Get the status of the drive. This\nis a bit mask of status flags.",33,{"inputs":[{"name":"ide"}],"output":{"name":"u8"}}],[11,"is_busy","","Return true if the drive is busy",33,{"inputs":[{"name":"ide"}],"output":{"name":"bool"}}],[11,"is_ready","","Return true if the drive is ready",33,{"inputs":[{"name":"ide"}],"output":{"name":"bool"}}],[11,"wait_for_drive","","Wait for the drive to become ready",33,{"inputs":[{"name":"ide"}],"output":null}],[11,"get_block_size","","block size = sector size",33,{"inputs":[{"name":"ide"}],"output":{"name":"usize"}}],[11,"read_block","","",33,{"inputs":[{"name":"ide"},{"name":"usize"},{"name":"blockdatabuffer"}],"output":null}],[11,"write_block","","",33,{"inputs":[{"name":"ide"},{"name":"usize"},{"name":"blockdatabuffer"}],"output":null}],[0,"nbb","os1::io","A Non-blocking buffer implementation",null,null],[3,"NonBlockingBuffer","os1::io::nbb","A non-blocking circular buffer for use\nby interrupt handlers",null,null],[12,"buffer","","",28,null],[12,"front","","",28,null],[12,"size","","",28,null],[11,"new","os1::io","",28,{"inputs":[{"name":"nonblockingbuffer"},{"name":"usize"}],"output":{"name":"nonblockingbuffer"}}],[11,"get","","Get the next character in the stream if there is one",28,{"inputs":[{"name":"nonblockingbuffer"}],"output":{"name":"option"}}],[11,"next","","",28,{"inputs":[{"name":"nonblockingbuffer"}],"output":{"name":"option"}}],[11,"put","","Put the given character at the end of the buffer.",28,{"inputs":[{"name":"nonblockingbuffer"},{"name":"char"}],"output":null}],[0,"machine","os1","This is the Rust-side handle for assembly code. Most of the FFI handles are\nin this module.",null,null],[5,"inb","os1::machine","a wrapper around inb",null,null],[5,"inl","","a wrapper around inl",null,null],[5,"outb","","a wrapper around outb",null,null],[5,"outl","","a wrapper around outl",null,null],[5,"ltr","","a wrapper around ltr",null,null],[5,"pit_do_init","","Initialize the PIT with the given divide",null,null],[5,"vmm_on","","Turn on VM and load cr3 with the given value",null,null],[5,"invlpg","","Flush the page from the TLB",null,null],[5,"cli","","a wrapper around cli",null,null],[5,"sti","","a wrapper around sti",null,null],[5,"irq0","","A handler for IRQ 0",null,null],[5,"irq1","","A handler for IRQ 1",null,null],[5,"irq2","","A handler for IRQ 2",null,null],[5,"irq3","","A handler for IRQ 3",null,null],[5,"irq4","","A handler for IRQ 4",null,null],[5,"irq5","","A handler for IRQ 5",null,null],[5,"irq6","","A handler for IRQ 6",null,null],[5,"irq7","","A handler for IRQ 7",null,null],[5,"irq8","","A handler for IRQ 8",null,null],[5,"irq9","","A handler for IRQ 9",null,null],[5,"irq10","","A handler for IRQ 10",null,null],[5,"irq11","","A handler for IRQ 11",null,null],[5,"irq12","","A handler for IRQ 12",null,null],[5,"irq13","","A handler for IRQ 13",null,null],[5,"irq14","","A handler for IRQ 14",null,null],[5,"irq15","","A handler for IRQ 15",null,null],[5,"proc_yield","","An unsafe proc_yield handle that saves the context of the current\nprocess before switching. *Do not* call this function directly! Instead,\nuse `process::proc_yield`, which is a wrapper around this function.",null,null],[5,"context_switch","","Do a context switch to `next_context` with the eflags register set to\n`eflags`. This function is called by `process::proc_yield`",null,null],[5,"eflags","","Returns the value of eflags",null,null],[5,"page_fault_handler","","The assembly handle for the page fault handler. This function calls\n`vmm_page_fault`.",null,null],[0,"memory","os1","This module contains everything that has to do with memory",null,null],[3,"AddressSpace","os1::memory","The address space of a single process",null,null],[12,"page_dir","","paddr of this addr space's PD",35,null],[12,"kmap_index","","the index of the first un-kmapped page",35,null],[12,"lock","","a lock for the address space",35,null],[12,"req_pid","","The PID of the process the current share request is going to",35,null],[12,"req_paddr","","The frame the current share request is for",35,null],[12,"req_bar","","A barrier for page-sharing",35,null],[12,"req_wait","","A waiting list for other processes who are expecting this\nprocess to share with them",35,null],[5,"vmm_page_fault","","The Rust-side code of the page fault handler.",null,{"inputs":[{"name":"usize"}],"output":null}],[5,"init","","Initialize all memory subsystems",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":null}],[0,"rust_alloc","","This module contains the outside interface with the kernels memory allocator.\nrustc will look for these functions.",null,null],[5,"__rust_allocate","os1::memory::rust_alloc","Return a pointer to `size` bytes of memory aligned to `align`.",null,null],[5,"__rust_deallocate","","Deallocates the memory referenced by `ptr`.",null,null],[5,"__rust_reallocate","","Resize the allocation referenced by `ptr` to `size` bytes.",null,null],[5,"__rust_reallocate_inplace","","Resize the allocation referenced by `ptr` to `size` bytes.",null,null],[5,"__rust_usable_size","","Returns the usable size of an allocation created with the specified the\n`size` and `align`.",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"usize"}}],[5,"__rust_stats_print","","Prints implementation-defined allocator statistics.",null,{"inputs":[],"output":null}],[0,"heap","os1::memory","This file contains the memory allocator used by the rust_alloc module",null,null],[3,"Block","os1::memory::heap","A struct representing a heap block.",null,null],[5,"round_to_block_align","","Round up to the nearest multiple of `BLOCK_ALIGN`",null,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[5,"round_to_n","","Round the size to `n`. `n` must be a power of 2",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"usize"}}],[5,"init","","Initialize the kernel heap",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":null}],[5,"malloc","","Return a pointer to `size` bytes of memory aligned to `align`.",null,null],[5,"free","","Deallocates the memory referenced by `ptr`.",null,null],[5,"usable_size","","Returns the usable size of an allocation created with the specified the\n`size` and `align`.",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"usize"}}],[5,"print_stats","","Prints implementation-defined allocator statistics.",null,{"inputs":[],"output":null}],[5,"get_block_stats","","Helper method to compute stats",null,null],[7,"BLOCK_ALIGN","","A const representing the minimum alignment of any block.\nIt is effectively a const, but it has to be initialized at startup because `size_of` is\nnon-const.",null,null],[7,"START","","The start address of the kernel heap",null,null],[7,"END","","The end address of the kernel heap. That is, the first address that is not in the heap.",null,null],[7,"free_list","","A pointer to the first free heap block",null,null],[7,"SUCC_MALLOCS","","The number of successful mallocs (for stats purposes)",null,null],[7,"FAIL_MALLOCS","","The number of unsuccessful mallocs (for stats purposes)",null,null],[7,"FREES","","The number of successful frees (for stats purposes)",null,null],[17,"DEBUG","","A flag to turn on and off debugging output",null,null],[11,"get_head","","Returns the first word of the block, which will contain the size if this is a free block",36,{"inputs":[{"name":"block"}],"output":{"name":"usize"}}],[11,"set_head","","Sets the header to the given value",36,{"inputs":[{"name":"block"},{"name":"usize"}],"output":null}],[11,"get_foot","","Returns the last word of the block, which will contain the size if this is a free block",36,{"inputs":[{"name":"block"}],"output":{"name":"usize"}}],[11,"set_foot","","Sets the footer to the given value",36,{"inputs":[{"name":"block"},{"name":"usize"}],"output":null}],[11,"get_free_bits","","Gets the 4 free bits of the block",36,{"inputs":[{"name":"block"}],"output":{"name":"u8"}}],[11,"set_next","","Set the forward pointer (but not the free bits)",36,null],[11,"set_prev","","Set the backward pointer",36,null],[11,"is_free","","Returns true if the block is a valid free block.\nThis method does a lot of sanity checiking",36,{"inputs":[{"name":"block"}],"output":{"name":"bool"}}],[11,"mark_free","","Set the free bits",36,{"inputs":[{"name":"block"}],"output":null}],[11,"mark_used","","Clear the free bits.\nThe block should already be removed from the free list",36,{"inputs":[{"name":"block"}],"output":null}],[11,"get_size","","Return the size of the block (user-usable data size)",36,{"inputs":[{"name":"block"}],"output":{"name":"usize"}}],[11,"set_size","","Set the size of block",36,{"inputs":[{"name":"block"},{"name":"usize"}],"output":null}],[11,"get_contiguous_next","","Returns the heap block immediately following this one",36,null],[11,"get_contiguous_prev","","Returns the heap block immediately preceding this one\nor null if there is no valid previous block.",36,null],[11,"get_free_next","","Returns the forward ptr of the block (excluding the free bits)",36,null],[11,"get_free_prev","","Returns the backward ptr of the block",36,null],[11,"remove","","Remove from free list. Clear forward/backward pointers",36,{"inputs":[{"name":"block"}],"output":null}],[11,"insert","","Add to head of free list",36,{"inputs":[{"name":"block"}],"output":null}],[11,"merge_with_next","","Merge this block with the next block.\nRemoves the second block from the free list before merging",36,{"inputs":[{"name":"block"}],"output":null}],[11,"split","","Split the block so that it is the given size.\nInsert the new block into the free list.\nThe block must be large enough to split (`>= 2*BLOCK_ALIGN`).\nThe block must be free.\nThe new size must be a multiple of `BLOCK_ALIGN`.",36,{"inputs":[{"name":"block"},{"name":"usize"}],"output":null}],[11,"is_match","","Returns true if this block matches the size and alignment.\nReturns the size at which the block should be split to obtain\nan aligned block; the second return value is meaningless if\nwe return false.",36,null],[0,"physmem","os1::memory","Physical memory management",null,null],[3,"Frame","os1::memory::physmem","A physical memory frame",null,null],[12,"mem","","",37,null],[3,"FrameInfoSection","","Should take up 4MiB on a 32-bit machine.\nThere is one frame info for each frame, associated by frame index",null,null],[12,"arr","","",38,null],[3,"FrameInfo","","Frame info\n```\nWhen free\n31                 20           0\n[nnnnnnnnnnnnnnnnnnnn           1]\n ^-- next free index            ^-- free bit",null,null],[12,"info","","",39,null],[3,"SharedFrameInfo","","A struct to keep track of information related to shared\nphysical frames.",null,null],[12,"pad","","needs to be at least 4B aligned",40,null],[12,"list","","list of sharers: (pid, vaddr)",40,null],[5,"init","","Initialize physical memory frames using the rest of physical memory.\nThis function detects all available physical memory.",null,{"inputs":[{"name":"usize"}],"output":null}],[7,"FRAME_INFO","","Array of `FrameInfo`. This is a pointer to the region of memory used\nto hold physical memory allocation metadata.",null,null],[7,"FREE_FRAMES","","The index of the first free frame in a LIFO list.\n0 => empty list",null,null],[11,"alloc","","Allocate a frame and return its physical address",37,{"inputs":[{"name":"frame"}],"output":{"name":"usize"}}],[11,"free","","Free the frame with the given index",37,{"inputs":[{"name":"frame"},{"name":"usize"}],"output":null}],[11,"share","","Add the given pid as a sharer of this frame.",37,{"inputs":[{"name":"frame"},{"name":"usize"},{"name":"usize"},{"name":"usize"}],"output":null}],[11,"index","","",37,{"inputs":[{"name":"frame"},{"name":"usize"}],"output":{"name":"usize"}}],[11,"index_mut","","",37,{"inputs":[{"name":"frame"},{"name":"usize"}],"output":{"name":"usize"}}],[11,"index","","",38,{"inputs":[{"name":"frameinfosection"},{"name":"usize"}],"output":{"name":"frameinfo"}}],[11,"index_mut","","",38,{"inputs":[{"name":"frameinfosection"},{"name":"usize"}],"output":{"name":"frameinfo"}}],[11,"alloc","","Allocate the frame referred to by this `FrameInfo`.\nNOTE: this should only be called on the first frame in the free list",39,{"inputs":[{"name":"frameinfo"}],"output":null}],[11,"free","","Free the frame referred to by this FrameInfo\nif this is the last sharere; otherwise, just remove this\nprocess's `SharedFrameInfo`.",39,{"inputs":[{"name":"frameinfo"}],"output":null}],[11,"get_index","","Get the index of the `Frame`",39,{"inputs":[{"name":"frameinfo"}],"output":{"name":"usize"}}],[11,"set_free","","Set the free bit of this `FrameInfo` to 1 if `free` is true; else 0",39,{"inputs":[{"name":"frameinfo"},{"name":"bool"}],"output":null}],[11,"get_next_free","","Get the index of the next free frame",39,{"inputs":[{"name":"frameinfo"}],"output":{"name":"usize"}}],[11,"set_next_free","","Set the index of the next free frame",39,{"inputs":[{"name":"frameinfo"},{"name":"usize"}],"output":null}],[11,"has_shared_info","","Returns true if this frame has shared frame info.",39,{"inputs":[{"name":"frameinfo"}],"output":{"name":"bool"}}],[11,"get_shared_info","","Get the `SharedFrameInfo` of this frame",39,{"inputs":[{"name":"frameinfo"}],"output":{"name":"option"}}],[11,"set_shared_info","","Set the `SharedFrameInfo` of this frame",39,null],[11,"clear_shared_info","","Remove the `SharedFrameInfo` ptr of the frame",39,{"inputs":[{"name":"frameinfo"}],"output":null}],[11,"new","","",40,{"inputs":[{"name":"sharedframeinfo"}],"output":{"name":"sharedframeinfo"}}],[0,"regionmap","os1::memory","Module for detecting available physical memory",null,null],[3,"MemoryListEntry","os1::memory::regionmap","Represents an entry in the list of memory regions generated by the E820\nBIOS call.",null,null],[12,"base_l","","",41,null],[12,"base_h","","",41,null],[12,"length_l","","",41,null],[12,"length_h","","",41,null],[12,"region_type","","",41,null],[12,"acpi","","",41,null],[3,"Region","","Represents a region of memory",null,null],[12,"start","","",42,null],[12,"end","","",42,null],[12,"usable","","",42,null],[3,"RegionMap","","Represents a map of memory regions",null,null],[12,"list","","",43,null],[12,"index","","",43,null],[5,"find","","Find the length and type of the most restrictive\nmapping for `addr` based on the E820 BIOS call",null,{"inputs":[{"name":"usize"}],"output":{"name":"option"}}],[5,"find_next","","Find the beginning address of the next region of memory\nbased on the E820 BIOS call",null,{"inputs":[{"name":"usize"}],"output":{"name":"usize"}}],[7,"memory_map_count","","",null,null],[7,"memory_map","","",null,null],[11,"dump","","Print this region for debugging purposes",42,{"inputs":[{"name":"region"}],"output":null}],[11,"new","","Produce a map of all memory after start.\nThis is a 32-bit OS, so we only have to deal with 4GB",43,null],[11,"dump","","Print out the memory map for debugging purposes",43,{"inputs":[{"name":"regionmap"}],"output":null}],[11,"next","","Returns the index of the next avail frame and number of\navailable frames OR None if there aren't any more.",43,{"inputs":[{"name":"regionmap"}],"output":{"name":"option"}}],[0,"vm","os1::memory","A module for virtual memory management",null,null],[3,"AddressSpace","os1::memory::vm","The address space of a single process",null,null],[12,"page_dir","","paddr of this addr space's PD",35,null],[12,"kmap_index","","the index of the first un-kmapped page",35,null],[12,"lock","","a lock for the address space",35,null],[12,"req_pid","","The PID of the process the current share request is going to",35,null],[12,"req_paddr","","The frame the current share request is for",35,null],[12,"req_bar","","A barrier for page-sharing",35,null],[12,"req_wait","","A waiting list for other processes who are expecting this\nprocess to share with them",35,null],[5,"vmm_page_fault","","The Rust-side code of the page fault handler.",null,{"inputs":[{"name":"usize"}],"output":null}],[5,"init_shared_pdes","","Create `n` PDEs to direct map the memory start from the `i`th page.\nunsafe because it deals with raw pointers and static muts.",null,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":null}],[5,"init","","Initialize virtual memory management but do not turn on VM.",null,{"inputs":[{"name":"usize"}],"output":null}],[0,"addr_space","","A module process address spaces",null,null],[3,"AddressSpace","os1::memory::vm::addr_space","The address space of a single process",null,null],[12,"page_dir","","paddr of this addr space's PD",35,null],[12,"kmap_index","","the index of the first un-kmapped page",35,null],[12,"lock","","a lock for the address space",35,null],[12,"req_pid","","The PID of the process the current share request is going to",35,null],[12,"req_paddr","","The frame the current share request is for",35,null],[12,"req_bar","","A barrier for page-sharing",35,null],[12,"req_wait","","A waiting list for other processes who are expecting this\nprocess to share with them",35,null],[5,"vmm_page_fault","","The Rust-side code of the page fault handler.",null,{"inputs":[{"name":"usize"}],"output":null}],[11,"new","os1::memory","Create a new address space and set up the PD.",35,{"inputs":[{"name":"addressspace"}],"output":{"name":"addressspace"}}],[11,"map","","Map `virt` to `phys` in the address space. The method first\ntries to acquire the address space lock if `lock` is true.",35,{"inputs":[{"name":"addressspace"},{"name":"usize"},{"name":"usize"},{"name":"bool"}],"output":null}],[11,"kmap","","Map the given `paddr` for temporary use by the kernel and return a mut reference to the\nframe.\nNOTE: should only be called on the current address space because it assumes that the PD is\nat PD_ADDRESS",35,{"inputs":[{"name":"addressspace"},{"name":"usize"}],"output":{"name":"frame"}}],[11,"unmap","","Remove any mapping for this virtual address. The method first tries to acquire the address\nspace lock if `lock` is true.",35,{"inputs":[{"name":"addressspace"},{"name":"usize"},{"name":"bool"}],"output":null}],[11,"v_to_p","","Returns the current physical address mapped to the given virtual address\nor None if it is not mapped. The method first tries to acquire the address\nspace lock if `lock` is true.",35,{"inputs":[{"name":"addressspace"},{"name":"usize"},{"name":"bool"}],"output":{"name":"option"}}],[11,"activate","","Activate the current address space and turn on VM if needed",35,{"inputs":[{"name":"addressspace"}],"output":null}],[11,"request_share","","Send a page-share request to the process with PID `pid` for\nthe frame mapped to `vaddr` in this address space.",35,{"inputs":[{"name":"addressspace"},{"name":"usize"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"accept_share","","Creates a mapping in this process's address space for the\nfirst page-share request from the process with the given PID\nto the given page.",35,{"inputs":[{"name":"addressspace"},{"name":"usize"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"clear","","Remove all non-kernel mappings in this address space.\nNOTE: must run while this address space is active",35,{"inputs":[{"name":"addressspace"}],"output":null}],[11,"drop","","Deallocate the page directory.\nNOTE: cannot run while the address space is active",35,{"inputs":[{"name":"addressspace"}],"output":null}],[0,"structs","os1::memory::vm","A module containing useful structs to abstract paging structures",null,null],[3,"PagingEntry","os1::memory::vm::structs","A single entry in a page directory or table\n```\n31                 12  9       0\n[                    000 flags  ]\n```",null,null],[12,"entry","","",44,null],[3,"VMTable","","An abstraction of page directories and page tables",null,null],[12,"entries","","",45,null],[11,"clone","","",44,{"inputs":[{"name":"pagingentry"}],"output":{"name":"pagingentry"}}],[11,"new","","Get a blank entry",44,{"inputs":[{"name":"pagingentry"}],"output":{"name":"pagingentry"}}],[11,"set_present","","Set the present bit.\ntrue = present; false = not present",44,{"inputs":[{"name":"pagingentry"},{"name":"bool"}],"output":null}],[11,"set_read_write","","Set the read/write bit.\ntrue = read/write, false = read-only",44,{"inputs":[{"name":"pagingentry"},{"name":"bool"}],"output":null}],[11,"set_privelege_level","","Set the privelege level bit.\ntrue = all, false = kernel mode only",44,{"inputs":[{"name":"pagingentry"},{"name":"bool"}],"output":null}],[11,"set_caching","","Set caching bit.\ntrue = write-through, false = write-back",44,{"inputs":[{"name":"pagingentry"},{"name":"bool"}],"output":null}],[11,"set_flag","","Set the `index`-th flag to `value`.\ntrue = 1; false = 0",44,{"inputs":[{"name":"pagingentry"},{"name":"u8"},{"name":"bool"}],"output":null}],[11,"set_address","","Set the upper 20 bits of the entry to the upper 20 bits of `address`",44,{"inputs":[{"name":"pagingentry"},{"name":"usize"}],"output":null}],[11,"is_flag","","Return true if the `index`-th bit is set",44,{"inputs":[{"name":"pagingentry"},{"name":"u8"}],"output":{"name":"bool"}}],[11,"get_address","","Return the upper 20-bits of the entry",44,{"inputs":[{"name":"pagingentry"}],"output":{"name":"usize"}}],[11,"free","","Free the frame pointed to if `dealloc` and mark this entry not present.",44,{"inputs":[{"name":"pagingentry"},{"name":"bool"}],"output":null}],[11,"new","","Returns a reference to a new `VMTable` and its physical address.\nThe new table is kmapped if necessary, and is always cleared.",45,null],[11,"index","","",45,{"inputs":[{"name":"vmtable"},{"name":"usize"}],"output":{"name":"pagingentry"}}],[11,"index_mut","","",45,{"inputs":[{"name":"vmtable"},{"name":"usize"}],"output":{"name":"pagingentry"}}],[7,"SHARED_PDES","os1::memory::vm","A list of shared PDEs direct mapping the beginning of memory",null,null],[7,"NUM_SHARED","","The number of shared PDEs (for convenience)",null,null],[7,"PD_ADDRESS","","The virtual address to which the PD is mapped",null,null],[7,"KMAP_ADDRESS","","The beginning of kmap memory",null,null],[7,"USER_ADDRESS","","The beginning of user memory",null,null],[7,"VMM_ON","","Is VM on?",null,null],[0,"process","os1","A module for process management",null,null],[3,"Process","os1::process","Represents a single process, its identity, resources, etc.",null,null],[12,"name","","Name of the process; not necessarily unique",46,null],[12,"pid","","Unique 32-bit identifier",46,null],[12,"run","","The routine of the process",46,null],[12,"state","","The current state of the process",46,null],[12,"stack","","A pointer to the kheap-allocated stack space for this process's\nkernel stack. This pointer is to the bottom of the stack, not the head.",46,null],[12,"kcontext","","The saved kernel context for context switching",46,null],[12,"addr_space","","The virtual memory address space of the process",46,null],[12,"disable_cnt","","Number of calls to interrupts::on() while this process was running\nInterrupts are on if `disable_cnt == 0`",46,null],[12,"buffer","","A keyboard input buffer",46,null],[12,"cwf","","Current working file (inode number)",46,null],[12,"path","","Path taken to the cwf (a stack of inode #s), not including the cwf",46,null],[4,"CF","","An enum representing change of directory",null,null],[13,"Back","","\"..\"",47,null],[13,"Next","","Next file",47,null],[4,"State","","An enum representing the possible states of a process",null,null],[13,"INIT","","Process is created, but not ready",48,null],[13,"READY","","Process is in the ready q",48,null],[13,"RUNNING","","Process is running (not on the ready q or blocked)",48,null],[13,"BLOCKED","","Process is blocked on a q",48,null],[13,"TERMINATED","","Process has died",48,null],[5,"init","","Initialize the process subsystem.\nThis creates the init, idle, and reaper processes, but does not\nstart any of them yet.",null,{"inputs":[],"output":null}],[5,"start_proc","","The entry point of all processes",null,{"inputs":[],"output":null}],[5,"proc_yield","","A safe wrapper around machine::proc_yield.",null,{"inputs":[{"name":"option"}],"output":null}],[5,"_proc_yield","","The unsafe function that does the actual work of choosing the\nnext process and switching to it.",null,{"inputs":[{"name":"option"}],"output":null}],[5,"exit","","Called by the current process to exit with the given exit code",null,{"inputs":[{"name":"usize"}],"output":null}],[0,"context","","A module for saving a process's context",null,null],[3,"KContext","os1::process::context","A struct representing the contents of the general purpose registers\nas produced by the `pusha` instruction.",null,null],[12,"edi","","",49,null],[12,"esi","","",49,null],[12,"ebp","","",49,null],[12,"esp","","",49,null],[12,"ebx","","",49,null],[12,"edx","","",49,null],[12,"ecx","","",49,null],[12,"eax","","",49,null],[5,"store_kcontext","","Save the `KContext` of the current process to its process struct",null,null],[11,"clone","","",49,{"inputs":[{"name":"kcontext"}],"output":{"name":"kcontext"}}],[11,"new","","Create a new empty context struct",49,{"inputs":[{"name":"kcontext"}],"output":{"name":"kcontext"}}],[0,"focus","os1::process","A module for process focus",null,null],[5,"focus","os1::process::focus","Set focus on the given pid if one is given,\nor on the CURRENT_PROCESS if None is given.",null,{"inputs":[{"name":"option"}],"output":null}],[5,"get_focused","","Returns the FOCUSED_PID in a thread-safe way.",null,{"inputs":[],"output":{"name":"usize"}}],[7,"FOCUSED_PID","","The pid of the currently focused process",null,null],[0,"proc_table","os1::process","A module for the process table, a table mapping each PID to a process struct",null,null],[3,"ProcessTable","os1::process::proc_table","A process table implemented as an indexable deque",null,null],[12,"pt_head","","",50,null],[12,"first_pid","","",50,null],[12,"capacity","","",50,null],[12,"size","","",50,null],[3,"ProcessTableNode","","A single node in the `ProcessTable`, holding mappings\nfor `NODE_SIZE` processes",null,null],[12,"map","","",51,null],[12,"next","","",51,null],[7,"PROCESS_TABLE","","The process table for the kernel",null,null],[7,"TABLE_LOCK","","A lock for the `PROCESS_TABLE`",null,null],[17,"NODE_SIZE","","Number of PIDs mapped by a single `ProcessTableNode`",null,null],[11,"new","","",50,{"inputs":[{"name":"processtable"}],"output":{"name":"processtable"}}],[11,"push","","Add the new process to the end of the Table. Since processes\nare created with sequential PIDs, we already know the PID.",50,null],[11,"remove","","Void the entry in the table. This should be done just before\ndeallocating the process.",50,{"inputs":[{"name":"processtable"},{"name":"usize"}],"output":null}],[11,"get","","Get the process with the matching PID",50,{"inputs":[{"name":"processtable"},{"name":"usize"}],"output":{"name":"option"}}],[11,"free","","Free as many `ProcessTableNode`s as possible",50,{"inputs":[{"name":"processtable"}],"output":null}],[11,"get_node","","Get the node containing the given PID",50,{"inputs":[{"name":"processtable"},{"name":"usize"}],"output":{"name":"processtablenode"}}],[11,"get_node_mut","","Get the node containing the given PID",50,{"inputs":[{"name":"processtable"},{"name":"usize"}],"output":{"name":"processtablenode"}}],[11,"get_last_node","","Get the last node in the table",50,{"inputs":[{"name":"processtable"}],"output":{"name":"processtablenode"}}],[11,"new","","",51,null],[11,"destroy","","",51,null],[11,"is_empty","","",51,{"inputs":[{"name":"processtablenode"}],"output":{"name":"bool"}}],[11,"index","","",51,null],[11,"index_mut","","",51,null],[0,"ready_queue","os1::process","A module for the ready queue",null,null],[5,"make_ready","os1::process::ready_queue","Add the process to the ready queue",null,null],[5,"get_next","","Unqueue and return the next ready process.\nNOTE: returns null if there are no ready processes",null,null],[7,"READY_QUEUE","","The ready queue. A queue containing all processes that are ready to be scheduled.",null,null],[0,"idle","os1::process","A module for the idle process, a process that runs when there is\nnothing else left to do.",null,null],[5,"init","os1::process::idle","Create the idle process but do not start it until we need it",null,{"inputs":[],"output":null}],[5,"run","","Just waste a quantum and hopefully there will be something to do",null,{"inputs":[{"name":"process"}],"output":{"name":"usize"}}],[7,"IDLE_PROCESS","","The idle process",null,null],[0,"init","os1::process","A module for the init process",null,null],[5,"run","os1::process::init","The init process routine",null,{"inputs":[{"name":"process"}],"output":{"name":"usize"}}],[0,"reaper","os1::process","A module for the reaper process, a process which frees the resources\nof dead processes.",null,null],[5,"run","os1::process::reaper","The reaper process routine:\nIf there are dead processes, pop them from the\nREAPER_QUEUE and free their resources.",null,{"inputs":[{"name":"process"}],"output":{"name":"usize"}}],[5,"reaper_add","","Add a dead process to the reaper queue.\nNOTE: This should only be done for processes that will never run again",null,null],[5,"init","","Create the reaper process and add it to the ready queue",null,{"inputs":[],"output":null}],[7,"REAPER_SEMAPHORE","","The reaper blocks onto this semaphore until enough have died",null,null],[7,"REAPER_QUEUE","","The reaper queue. A queue of dead processes",null,null],[0,"user","os1::process","A module for user processes",null,null],[5,"run","os1::process::user","",null,{"inputs":[{"name":"process"}],"output":{"name":"usize"}}],[5,"get_prev","","",null,null],[5,"get_next","","",null,null],[5,"run2","","",null,{"inputs":[{"name":"process"}],"output":{"name":"usize"}}],[5,"run3","","",null,{"inputs":[{"name":"process"}],"output":{"name":"usize"}}],[5,"run4","","",null,{"inputs":[{"name":"process"}],"output":{"name":"usize"}}],[5,"run5","","",null,{"inputs":[{"name":"process"}],"output":{"name":"usize"}}],[7,"current","","",null,null],[7,"s1","","",null,null],[7,"s2","","",null,null],[17,"ROWS","","",null,null],[17,"COLS","","",null,null],[17,"NUM_LOOP","","",null,null],[6,"ProcessQueue","os1::process","Type alias for a queue of Processes",null,null],[7,"NEXT_ID","","The next available PID",null,null],[7,"CURRENT_PROCESS","","The current running process if there is one",null,null],[17,"STACK_SIZE","","Size of a kernel stack (number of words)",null,null],[11,"eq","","",47,{"inputs":[{"name":"cf"},{"name":"cf"}],"output":{"name":"bool"}}],[11,"ne","","",47,{"inputs":[{"name":"cf"},{"name":"cf"}],"output":{"name":"bool"}}],[11,"clone","","",47,{"inputs":[{"name":"cf"}],"output":{"name":"cf"}}],[11,"eq","","",48,{"inputs":[{"name":"state"},{"name":"state"}],"output":{"name":"bool"}}],[11,"ne","","",48,{"inputs":[{"name":"state"},{"name":"state"}],"output":{"name":"bool"}}],[11,"clone","","",48,{"inputs":[{"name":"state"}],"output":{"name":"state"}}],[11,"new","","Create a new process with the given name and routine. Because processes\nare a fundamental abstraction, they are too low level for me to use Rust well.\nFor this reason, a raw pointer is returned to the process, and it is the\njob of the caller to arrange for the process to be reaped.",46,null],[11,"get_stack","","A helper to get a kernel stack for this process",46,{"inputs":[{"name":"process"}],"output":null}],[11,"set_state","","Set the state of the process to `s`",46,{"inputs":[{"name":"process"},{"name":"state"}],"output":null}],[11,"get_state","","Get the state of the process",46,{"inputs":[{"name":"process"}],"output":{"name":"state"}}],[11,"get_pid","","Get the PID of this process",46,{"inputs":[{"name":"process"}],"output":{"name":"usize"}}],[11,"accept_kbd","","Start accepting keyboard input when this process\ngains focussed. The buffer will have the capacity\ngiven.",46,{"inputs":[{"name":"process"},{"name":"usize"}],"output":null}],[11,"cwf","","Return the inode number of the current working file",46,{"inputs":[{"name":"process"}],"output":{"name":"usize"}}],[11,"cf","","Change files to the given inode number if that file exists and is reachable from the cwf",46,{"inputs":[{"name":"process"},{"name":"cf"}],"output":null}],[11,"drop","","When the process is reaped, we must free its stack",46,{"inputs":[{"name":"process"}],"output":null}],[11,"fmt","","Allow processes to be printed elegantly in format strings",46,{"inputs":[{"name":"process"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","Two processes are the same if they have the same PID",46,{"inputs":[{"name":"process"},{"name":"process"}],"output":{"name":"bool"}}],[0,"sync","os1","A module for synchronization primitives",null,null],[3,"Semaphore","os1::sync","`Semaphore` is a much more Rustic semaphore. It returns an RAII\n`SemaphoreGuard`, which automatically calls \"up\" when it goes out of\nscope. This semaphore takes ownership of the data it is guarding, so that\nRust ownership and lifetime semantics can be used to guarantee safety of\nthe resource.",null,null],[12,"inner","","",52,null],[12,"data","","",52,null],[3,"StaticSemaphore","","`StaticSemaphore` is a semaphore implementation that can be used in\nstatics. It has a const constructor.",null,null],[12,"count","","",53,null],[12,"queue","","",53,null],[3,"SemaphoreGuard","","RAII SemaphoreGuard",null,null],[12,"semaphore","","",54,null],[12,"data","","",54,null],[3,"Barrier","","A Barrier implementation.",null,null],[12,"count","","",55,null],[12,"n","","",55,null],[12,"event","","",55,null],[3,"Event","","An Event data structure.",null,null],[12,"status","","",56,null],[0,"semaphore","","A semaphore implementation based on the rust Mutex<T> type",null,null],[3,"Semaphore","os1::sync::semaphore","`Semaphore` is a much more Rustic semaphore. It returns an RAII\n`SemaphoreGuard`, which automatically calls \"up\" when it goes out of\nscope. This semaphore takes ownership of the data it is guarding, so that\nRust ownership and lifetime semantics can be used to guarantee safety of\nthe resource.",null,null],[12,"inner","","",52,null],[12,"data","","",52,null],[3,"StaticSemaphore","","`StaticSemaphore` is a semaphore implementation that can be used in\nstatics. It has a const constructor.",null,null],[12,"count","","",53,null],[12,"queue","","",53,null],[3,"SemaphoreGuard","","RAII SemaphoreGuard",null,null],[12,"semaphore","","",54,null],[12,"data","","",54,null],[11,"new","os1::sync","Create a new semaphore with the the given count guarding the given value",52,{"inputs":[{"name":"semaphore"},{"name":"t"},{"name":"isize"}],"output":{"name":"semaphore"}}],[11,"down","","Acquire.\nreturns an RAII guard, so no need for up()",52,{"inputs":[{"name":"semaphore"}],"output":{"name":"semaphoreguard"}}],[11,"drop","","When the semaphore goes out of scope, it destroys the contents",52,{"inputs":[{"name":"semaphore"}],"output":null}],[11,"new","","Create a new `StaticSemaphore` with the given count",53,{"inputs":[{"name":"staticsemaphore"},{"name":"isize"}],"output":{"name":"staticsemaphore"}}],[11,"down","","Acquire",53,{"inputs":[{"name":"staticsemaphore"}],"output":null}],[11,"up","","Release",53,{"inputs":[{"name":"staticsemaphore"}],"output":null}],[11,"destroy","","Clean up.\nCannot implement Drop here because we want to be able\nto create a static semaphore.",53,{"inputs":[{"name":"staticsemaphore"}],"output":null}],[11,"new","","Create a guard referring to the given semaphore and data",54,{"inputs":[{"name":"semaphoreguard"},{"name":"staticsemaphore"},{"name":"unsafecell"}],"output":{"name":"semaphoreguard"}}],[11,"up","","",54,{"inputs":[{"name":"semaphoreguard"}],"output":null}],[11,"drop","","`SemaphoreGuard` is RAII, so dropping the guard calls up",54,{"inputs":[{"name":"semaphoreguard"}],"output":null}],[11,"deref","","",54,{"inputs":[{"name":"semaphoreguard"}],"output":{"name":"t"}}],[11,"deref_mut","","",54,{"inputs":[{"name":"semaphoreguard"}],"output":{"name":"t"}}],[0,"barrier","","A module containing a barrier implementation",null,null],[3,"Barrier","os1::sync::barrier","A Barrier implementation.",null,null],[12,"count","","",55,null],[12,"n","","",55,null],[12,"event","","",55,null],[11,"new","os1::sync","Create a new barrier for `n` processes",55,{"inputs":[{"name":"barrier"},{"name":"usize"}],"output":{"name":"barrier"}}],[11,"reach","","This process reaches the barrier",55,{"inputs":[{"name":"barrier"}],"output":null}],[0,"event","","A module containing an event implementation",null,null],[3,"Event","os1::sync::event","An Event data structure.",null,null],[12,"status","","",56,null],[11,"new","os1::sync","Creates a new `Event`",56,{"inputs":[{"name":"event"}],"output":{"name":"event"}}],[11,"wait","","Block this process until `notify` is called",56,{"inputs":[{"name":"event"}],"output":null}],[11,"notify","","Wake up all processes that called `wait` on this event",56,{"inputs":[{"name":"event"}],"output":null}],[11,"reset","","Reset the event before more processes can `wait`",56,{"inputs":[{"name":"event"}],"output":null}],[0,"vga","os1","This module contains a primitive display driver for the kernel\nwhile in VGA mode.",null,null],[0,"input","os1::vga","A module for showing user input boxes",null,null],[3,"TextArea","os1::vga::input","A multi-line input box for keyboard input with\nword-wrap",null,null],[12,"string","","",57,null],[12,"tbox","","",57,null],[3,"TextBox","","A single-line input box for keyboard input",null,null],[12,"tbox","","",58,null],[8,"InputElement","","",null,null],[10,"get_str","","",59,{"inputs":[{"name":"inputelement"}],"output":{"name":"string"}}],[11,"new","","Get a new empty textbox with the given dimensions and position",57,null],[11,"get_str","","Keep accepting characters until the user hits return",57,{"inputs":[{"name":"textarea"}],"output":{"name":"string"}}],[11,"new","","Get a new empty textbox with the given width and position",58,null],[11,"get_str","","",58,{"inputs":[{"name":"textbox"}],"output":{"name":"string"}}],[0,"rectangle","os1::vga","A module for primitive rectangle drawing",null,null],[3,"Rectangle","os1::vga::rectangle","Ann abstraction for drawing text inside a bounded box",null,null],[12,"height","","",60,null],[12,"width","","",60,null],[12,"pos","","",60,null],[12,"cursor","","",60,null],[12,"vga","","",60,null],[4,"Color","","Colors for VGA display",null,null],[13,"Black","","",61,null],[13,"Blue","","",61,null],[13,"Green","","",61,null],[13,"Cyan","","",61,null],[13,"Red","","",61,null],[13,"Pink","","",61,null],[13,"Brown","","",61,null],[13,"LightGray","","",61,null],[13,"DarkGray","","",61,null],[13,"LightBlue","","",61,null],[13,"LightGreen","","",61,null],[13,"LightCyan","","",61,null],[13,"LightRed","","",61,null],[13,"LightPink","","",61,null],[13,"Yellow","","",61,null],[13,"White","","",61,null],[11,"clone","","",60,{"inputs":[{"name":"rectangle"}],"output":{"name":"rectangle"}}],[11,"new","","Create a new Rectangle.",60,null],[11,"clear_screen","","A static method to clear the screen.",60,{"inputs":[{"name":"rectangle"}],"output":null}],[11,"paint","","Paint the rectangle with the background color",60,{"inputs":[{"name":"rectangle"}],"output":null}],[11,"put_char","","Draw the character at the cursor relative to the corner of rectangle\nif the character is inside the rectangle.",60,{"inputs":[{"name":"rectangle"},{"name":"char"}],"output":null}],[11,"put_str","","Render the string at the cursor using word wrapping.",60,{"inputs":[{"name":"rectangle"},{"name":"str"}],"output":null}],[11,"set_fg","","Set the foreground color",60,{"inputs":[{"name":"rectangle"},{"name":"color"}],"output":null}],[11,"set_bg","","Set the background color",60,{"inputs":[{"name":"rectangle"},{"name":"color"}],"output":null}],[11,"set_cursor","","Set the cursor position",60,null],[11,"write_str","","",60,{"inputs":[{"name":"rectangle"},{"name":"str"}],"output":{"name":"result"}}],[0,"vga","os1::vga","A module for VGA buffer manipulation",null,null],[3,"VGAChar","os1::vga::vga","Represents a single character in the VGA buffer.\nThe first byte represents the ASCII character. The next\n4 bits represent the background color. The last 4 bits\nrepresent the forground color.",null,null],[12,"ch","","",62,null],[12,"color","","",62,null],[3,"VGABuff","","Abstracts the VGA buffer",null,null],[12,"buff","","",63,null],[3,"VGA","","Safe wrapper around unsafe VGA buffer.\nProvides the abstraction of a cursor and \"screen\"",null,null],[12,"fg","","",64,null],[12,"bg","","",64,null],[12,"cursor","","",64,null],[4,"Color","","Colors for VGA display",null,null],[13,"Black","","",61,null],[13,"Blue","","",61,null],[13,"Green","","",61,null],[13,"Cyan","","",61,null],[13,"Red","","",61,null],[13,"Pink","","",61,null],[13,"Brown","","",61,null],[13,"LightGray","","",61,null],[13,"DarkGray","","",61,null],[13,"LightBlue","","",61,null],[13,"LightGreen","","",61,null],[13,"LightCyan","","",61,null],[13,"LightRed","","",61,null],[13,"LightPink","","",61,null],[13,"Yellow","","",61,null],[13,"White","","",61,null],[7,"VGA_BUFFER","","The VGA buffer",null,null],[17,"ROWS","","Number of rows in the VGA buffer",null,null],[17,"COLS","","Number of columns in the VGA buffer",null,null],[17,"VGA_CMD","","The VGA command port",null,null],[17,"VGA_DATA","","The VGA data port",null,null],[11,"clone","os1::vga::rectangle","",61,{"inputs":[{"name":"color"}],"output":{"name":"color"}}],[11,"clone","os1::vga::vga","",62,{"inputs":[{"name":"vgachar"}],"output":{"name":"vgachar"}}],[11,"clone","","",63,{"inputs":[{"name":"vgabuff"}],"output":{"name":"vgabuff"}}],[11,"clone","","",64,{"inputs":[{"name":"vga"}],"output":{"name":"vga"}}],[11,"set_fg","","Set the forground color of the character",62,{"inputs":[{"name":"vgachar"},{"name":"color"}],"output":null}],[11,"set_bg","","Set the background color of the character",62,{"inputs":[{"name":"vgachar"},{"name":"color"}],"output":null}],[11,"set_char","","Set the ASCII character",62,{"inputs":[{"name":"vgachar"},{"name":"char"}],"output":null}],[11,"index","","",63,null],[11,"index_mut","","",63,null],[11,"new","","Create a new VGA handle",64,{"inputs":[{"name":"vga"}],"output":{"name":"vga"}}],[11,"fill_rect","","Clear the rectangle and paint it with the background color",64,null],[11,"clear_screen","","Paint the whole screen black",64,{"inputs":[{"name":"vga"}],"output":null}],[11,"put_char","","Set character at the cursor",64,{"inputs":[{"name":"vga"},{"name":"char"}],"output":null}],[11,"set_fg","","Set foreground color of the cursor",64,{"inputs":[{"name":"vga"},{"name":"color"}],"output":null}],[11,"set_bg","","Set background color of the cursor",64,{"inputs":[{"name":"vga"},{"name":"color"}],"output":null}],[11,"set_cursor","","Set position of the cursor",64,null],[14,"printf!","os1","A macro for printing using format strings to the console\nwhen interrupts are enabled",null,null],[14,"bootlog!","","A macro for printing using format strings to the console\nwhen interrupts are not enabled",null,null]],"paths":[[3,"Debug"],[3,"LinkedList"],[3,"Rawlink"],[3,"Node"],[3,"Iter"],[3,"IterMut"],[3,"IntoIter"],[3,"StaticLinkedList"],[3,"Rawlink"],[3,"Node"],[3,"Iter"],[3,"IterMut"],[3,"IntoIter"],[3,"Vec"],[3,"IntoIter"],[3,"String"],[3,"OFSHandle"],[3,"OFS"],[3,"File"],[3,"OFSDate"],[3,"Metadata"],[3,"Inode"],[3,"Dnode"],[3,"Error"],[3,"TableDescriptor"],[3,"IDTDescr"],[3,"TSSDescriptor"],[3,"TSS"],[3,"NonBlockingBuffer"],[8,"InputStream"],[8,"OutputStream"],[3,"BlockDataBuffer"],[8,"BlockDevice"],[3,"IDE"],[4,"IDEStatus"],[3,"AddressSpace"],[3,"Block"],[3,"Frame"],[3,"FrameInfoSection"],[3,"FrameInfo"],[3,"SharedFrameInfo"],[3,"MemoryListEntry"],[3,"Region"],[3,"RegionMap"],[3,"PagingEntry"],[3,"VMTable"],[3,"Process"],[4,"CF"],[4,"State"],[3,"KContext"],[3,"ProcessTable"],[3,"ProcessTableNode"],[3,"Semaphore"],[3,"StaticSemaphore"],[3,"SemaphoreGuard"],[3,"Barrier"],[3,"Event"],[3,"TextArea"],[3,"TextBox"],[8,"InputElement"],[3,"Rectangle"],[4,"Color"],[3,"VGAChar"],[3,"VGABuff"],[3,"VGA"]]};
initSearch(searchIndex);
